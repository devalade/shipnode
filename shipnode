#!/usr/bin/env bash

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# ShipNode version
VERSION="1.1.0"

# Helper functions
error() {
    echo -e "${RED}Error: $1${NC}" >&2
    exit 1
}

success() {
    echo -e "${GREEN}âœ“ $1${NC}"
}

info() {
    echo -e "${BLUE}â†’ $1${NC}"
}

warn() {
    echo -e "${YELLOW}âš  $1${NC}"
}

# Gum detection for enhanced UI
has_gum() {
    command -v gum &> /dev/null
}

# Check if enhanced UI is available
USE_GUM=false
if has_gum; then
    USE_GUM=true
fi

# Release management helper functions
generate_release_timestamp() {
    date +"%Y%m%d%H%M%S"
}

get_release_path() {
    local timestamp=$1
    echo "$REMOTE_PATH/releases/$timestamp"
}

setup_release_structure() {
    ssh -T -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" bash << ENDSSH
        mkdir -p $REMOTE_PATH/{releases,shared,.shipnode}
        if [ ! -f $REMOTE_PATH/.shipnode/releases.json ]; then
            echo "[]" > $REMOTE_PATH/.shipnode/releases.json
        fi
ENDSSH
}

acquire_deploy_lock() {
    local result
    result=$(ssh -T -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" bash -s "$REMOTE_PATH" << 'ENDSSH'
        REMOTE_PATH="$1"
        mkdir -p "$REMOTE_PATH/.shipnode"
        LOCK_FILE="$REMOTE_PATH/.shipnode/deploy.lock"

        # Check for stale lock (older than 30 minutes)
        if [ -f "$LOCK_FILE" ]; then
            LOCK_AGE=$(( $(date +%s) - $(stat -c %Y "$LOCK_FILE") ))
            if [ "$LOCK_AGE" -gt 1800 ]; then
                echo "Removing stale lock file (${LOCK_AGE}s old)"
                rm -f "$LOCK_FILE"
            else
                echo "ERROR: Deployment in progress (lock age: ${LOCK_AGE}s)"
                exit 1
            fi
        fi

        # Create lock with timestamp
        date +%s > "$LOCK_FILE"
        echo "Lock acquired"
ENDSSH
    )
    echo "$result"
    if [[ "$result" == *"ERROR"* ]]; then
        error "Failed to acquire deployment lock"
    fi
}

release_deploy_lock() {
    ssh -T -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" "rm -f $REMOTE_PATH/.shipnode/deploy.lock" || true
}

switch_symlink() {
    local release_path=$1
    ssh -T -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" bash << ENDSSH
        cd $REMOTE_PATH
        ln -sfn $release_path current.tmp
        mv -Tf current.tmp current
ENDSSH
}

perform_health_check() {
    local max_retries=${HEALTH_CHECK_RETRIES:-3}
    local timeout=${HEALTH_CHECK_TIMEOUT:-30}
    local path=${HEALTH_CHECK_PATH:-/health}
    local port=${BACKEND_PORT:-3000}

    info "Running health check (${max_retries} retries, ${timeout}s timeout)..."

    for i in $(seq 1 $max_retries); do
        if ssh -T -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" "timeout $timeout curl -sf http://localhost:$port$path" > /dev/null 2>&1; then
            success "Health check passed"
            return 0
        fi
        [ $i -lt $max_retries ] && warn "Health check attempt $i failed, retrying..."
        sleep 2
    done

    error "Health check failed after $max_retries attempts"
    return 1
}

record_release() {
    local timestamp=$1
    local status=$2
    ssh -T -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" bash << ENDSSH
        cd $REMOTE_PATH/.shipnode
        CURRENT_DATE=\$(date -Is)
        jq ". + [{\"timestamp\":\"$timestamp\",\"date\":\"\$CURRENT_DATE\",\"status\":\"$status\"}]" releases.json > releases.json.tmp
        mv releases.json.tmp releases.json
ENDSSH
}

get_previous_release() {
    ssh -T -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" bash << ENDSSH
        cd $REMOTE_PATH/.shipnode
        cat releases.json | jq -r '.[-2].timestamp // empty'
ENDSSH
}

cleanup_old_releases() {
    local keep=${KEEP_RELEASES:-5}
    ssh -T -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" bash << ENDSSH
        cd $REMOTE_PATH/releases
        ls -t | tail -n +$((keep + 1)) | xargs -r rm -rf
ENDSSH
    info "Cleaned up old releases (keeping last $keep)"
}

rollback_to_release() {
    local timestamp=$1
    local release_path="$REMOTE_PATH/releases/$timestamp"

    info "Rolling back to release $timestamp..."
    switch_symlink "$release_path"

    if [ "$APP_TYPE" = "backend" ]; then
        ssh -T -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" "pm2 reload $PM2_APP_NAME"
    fi

    success "Rolled back to $timestamp"
}

# Setup PostgreSQL database
setup_postgresql() {
    # Check if PostgreSQL setup is enabled
    if [ "${DB_SETUP_ENABLED:-false}" != "true" ]; then
        return 0
    fi

    # Validate required variables
    if [ -z "$DB_NAME" ] || [ -z "$DB_USER" ] || [ -z "$DB_PASSWORD" ]; then
        warn "PostgreSQL setup enabled but DB_NAME, DB_USER, or DB_PASSWORD not set in config"
        return 1
    fi

    info "Setting up PostgreSQL..."

    ssh -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" \
        DB_NAME="$DB_NAME" \
        DB_USER="$DB_USER" \
        DB_PASSWORD="$DB_PASSWORD" \
        bash << 'ENDSSH'
        set -e

        # Detect if running as root and set sudo prefix
        SUDO=""
        if [ "$EUID" -ne 0 ]; then
            SUDO="sudo"
        fi

        # Install PostgreSQL
        if ! command -v psql &> /dev/null; then
            echo "Installing PostgreSQL..."
            $SUDO apt-get update
            $SUDO apt-get install -y postgresql postgresql-contrib
        else
            echo "PostgreSQL already installed: $(psql --version)"
        fi

        # Ensure PostgreSQL is running
        $SUDO systemctl start postgresql
        $SUDO systemctl enable postgresql

        # Create database and user
        echo "Creating database '$DB_NAME' and user '$DB_USER'..."

        # Create database if it doesn't exist
        $SUDO -u postgres psql -tc "SELECT 1 FROM pg_database WHERE datname = '$DB_NAME'" | grep -q 1 || \
            $SUDO -u postgres psql -c "CREATE DATABASE \"$DB_NAME\";"

        # Create user if it doesn't exist
        $SUDO -u postgres psql -tc "SELECT 1 FROM pg_user WHERE usename = '$DB_USER'" | grep -q 1 || \
            $SUDO -u postgres psql -c "CREATE USER \"$DB_USER\" WITH PASSWORD '$DB_PASSWORD';"

        # Update password if user already exists
        $SUDO -u postgres psql -c "ALTER USER \"$DB_USER\" WITH PASSWORD '$DB_PASSWORD';"

        # Grant privileges
        $SUDO -u postgres psql -c "GRANT ALL PRIVILEGES ON DATABASE \"$DB_NAME\" TO \"$DB_USER\";"

        # For PostgreSQL 15+, grant schema privileges
        $SUDO -u postgres psql -d "$DB_NAME" -c "GRANT ALL ON SCHEMA public TO \"$DB_USER\";" 2>/dev/null || true
        $SUDO -u postgres psql -d "$DB_NAME" -c "GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO \"$DB_USER\";" 2>/dev/null || true
        $SUDO -u postgres psql -d "$DB_NAME" -c "GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO \"$DB_USER\";" 2>/dev/null || true

        echo "PostgreSQL setup complete. Database '$DB_NAME' is ready."
        echo "Connection string: postgresql://$DB_USER:[password]@localhost:5432/$DB_NAME"
ENDSSH

    success "PostgreSQL database '$DB_NAME' configured"
}

# ============================================================================
# USER PROVISIONING FUNCTIONS
# ============================================================================

# Validation helpers
validate_username() {
    local username=$1
    if [[ ! "$username" =~ ^[a-zA-Z0-9_-]+$ ]] || [ ${#username} -gt 32 ]; then
        return 1
    fi
    return 0
}

validate_password_hash() {
    local hash=$1
    # Check if it's a valid crypt format (starts with $)
    if [[ "$hash" =~ ^\$[0-9]+\$ ]]; then
        return 0
    fi
    return 1
}

validate_ssh_key() {
    local key=$1
    # Check if key starts with valid key type
    if [[ "$key" =~ ^(ssh-rsa|ssh-ed25519|ecdsa-sha2-nistp256|ecdsa-sha2-nistp384|ecdsa-sha2-nistp521)\ .+ ]]; then
        return 0
    fi
    return 1
}

# Reusable yes/no prompt with default support
prompt_yes_no() {
    local prompt=$1 default=${2:-n}
    if [ "$default" = "y" ]; then
        read -p "$prompt (Y/n) " -n 1 -r
    else
        read -p "$prompt (y/N) " -n 1 -r
    fi
    echo
    [ -z "$REPLY" ] && { [ "$default" = "y" ] && return 0 || return 1; }
    [[ $REPLY =~ ^[Yy]$ ]]
}

# Generate password hash (reuses cmd_mkpasswd logic)
generate_password_hash() {
    local password=$1
    # Check if mkpasswd is available
    if ! command -v mkpasswd &> /dev/null; then
        error "mkpasswd not found. Install it with: sudo apt-get install whois"
    fi
    mkpasswd -m sha-512 "$password"
}

# Validate email address
validate_email() {
    local email=$1
    if [[ "$email" =~ ^[^@]+@[^@]+\.[^@]+$ ]]; then
        return 0
    fi
    return 1
}

# Read SSH key from file
read_key_file() {
    local file_path=$1
    # Expand tilde to home directory
    file_path="${file_path/#\~/$HOME}"

    if [ ! -f "$file_path" ]; then
        echo ""
        return 1
    fi

    cat "$file_path"
    return 0
}

# ============================================================================
# FRAMEWORK DETECTION & AUTO-CONFIGURATION
# ============================================================================

# Parse package.json safely and extract dependencies
parse_package_json() {
    local pkg_file="${1:-package.json}"
    
    if [ ! -f "$pkg_file" ]; then
        echo ""
        return 1
    fi
    
    # Check if jq is available
    if ! command -v jq &> /dev/null; then
        warn "jq not found, cannot parse package.json"
        echo ""
        return 1
    fi
    
    # Extract dependencies and devDependencies, combine them
    local jq_err
    jq_err=$(mktemp 2>/dev/null || printf "/tmp/shipnode_jq_err.%s" "$$")
    local deps
    deps=$(jq -r '(.dependencies // {}) + (.devDependencies // {}) | keys | join(",")' "$pkg_file" 2>"$jq_err")
    local jq_status=$?
    
    if [ $jq_status -ne 0 ]; then
        local jq_err_msg
        jq_err_msg=$(cat "$jq_err" 2>/dev/null || printf "")
        rm -f "$jq_err"
        if [ -n "$jq_err_msg" ]; then
            warn "Failed to parse $pkg_file: $jq_err_msg"
        else
            warn "Failed to parse $pkg_file with jq"
        fi
        echo ""
        return 1
    fi
    
    rm -f "$jq_err"
    
    if [ -z "$deps" ]; then
        echo ""
        return 1
    fi
    
    echo "$deps"
    return 0
}

# Suggest app type based on dependencies
suggest_app_type() {
    local deps=$1
    
    # Backend frameworks
    if [[ "$deps" =~ (express|@nestjs/core|@nestjs/common|fastify|koa|@hapi/hapi|hono) ]]; then
        echo "backend"
        return 0
    fi
    
    # Full-stack frameworks (suggest backend for reverse proxy)
    if [[ "$deps" =~ ((^|,)(next|nuxt)(,|$)|@remix-run) ]]; then
        echo "backend"
        return 0
    fi
    
    # Frontend frameworks
    if [[ "$deps" =~ (react|vue|svelte|solid-js|@angular/core) ]]; then
        echo "frontend"
        return 0
    fi
    
    echo "unknown"
    return 0
}

# Detect framework from package.json
detect_framework() {
    local pkg_file="${1:-package.json}"
    
    # Parse dependencies
    local deps=$(parse_package_json "$pkg_file")
    
    if [ -z "$deps" ]; then
        echo "none|unknown"
        return 0
    fi
    
    # Detect specific frameworks
    local framework="none"
    
    # Backend frameworks
    if [[ "$deps" =~ express ]]; then
        framework="Express"
    elif [[ "$deps" =~ @nestjs/core ]]; then
        framework="NestJS"
    elif [[ "$deps" =~ fastify ]]; then
        framework="Fastify"
    elif [[ "$deps" =~ koa ]]; then
        framework="Koa"
    elif [[ "$deps" =~ @hapi/hapi ]]; then
        framework="Hapi"
    elif [[ "$deps" =~ hono ]]; then
        framework="Hono"
    # Full-stack frameworks
    elif [[ "$deps" =~ (^|,)next(,|$) ]]; then
        framework="Next.js"
    elif [[ "$deps" =~ (^|,)nuxt(,|$) ]]; then
        framework="Nuxt"
    elif [[ "$deps" =~ @remix-run ]]; then
        framework="Remix"
    # Frontend frameworks
    elif [[ "$deps" =~ (^|,)react(,|$) ]]; then
        framework="React"
    elif [[ "$deps" =~ (^|,)vue(,|$) ]]; then
        framework="Vue"
    elif [[ "$deps" =~ svelte ]]; then
        framework="Svelte"
    elif [[ "$deps" =~ solid-js ]]; then
        framework="SolidJS"
    elif [[ "$deps" =~ @angular/core ]]; then
        framework="Angular"
    fi
    
    # Suggest app type
    local app_type=$(suggest_app_type "$deps")
    
    echo "${framework}|${app_type}"
    return 0
}

# Auto-detect port from package.json scripts
suggest_port() {
    local pkg_file="${1:-package.json}"
    
    if [ ! -f "$pkg_file" ] || ! command -v jq &> /dev/null; then
        echo ""
        return 1
    fi
    
    # Extract start and dev scripts
    local scripts=$(jq -r '.scripts // {} | .start // .dev // ""' "$pkg_file" 2>/dev/null)
    
    if [ -z "$scripts" ]; then
        echo ""
        return 1
    fi
    
    # Look for PORT= or :port patterns
    local port=""
    
    # Match PORT=3000
    if [[ "$scripts" =~ PORT=([0-9]+) ]]; then
        port="${BASH_REMATCH[1]}"
    # Match standalone :3000 while avoiding URLs/timestamps
    elif [[ "$scripts" =~ (^|[[:space:]])\:([0-9]{2,5})([[:space:]]|$) ]]; then
        port="${BASH_REMATCH[2]}"
    fi
    
    echo "$port"
    return 0
}

# ============================================================================
# INPUT VALIDATION FUNCTIONS
# ============================================================================

# Validate IP address or hostname
validate_ip_or_hostname() {
    local input=$1
    
    if [ -z "$input" ]; then
        return 1
    fi
    
    # Check if it's a valid IPv4 address
    if [[ "$input" =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}$ ]]; then
        # Validate each octet is 0-255
        IFS='.' read -ra OCTETS <<< "$input"
        for octet in "${OCTETS[@]}"; do
            # Ensure the octet contains only digits
            if ! [[ "$octet" =~ ^[0-9]+$ ]]; then
                return 1
            fi
            # Use base-10 to avoid octal interpretation of leading zeros
            if ((10#$octet < 0 || 10#$octet > 255)); then
                return 1
            fi
        done
        return 0
    fi
    
    # Check if it's a valid hostname
    if [[ "$input" =~ ^[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$ ]]; then
        return 0
    fi
    
    return 1
}

# Validate port number
validate_port() {
    local port=$1
    
    if [ -z "$port" ]; then
        return 1
    fi
    
    # Must be numeric
    if ! [[ "$port" =~ ^[0-9]+$ ]]; then
        return 1
    fi
    
    # Must be in valid range
    if [ "$port" -lt 1 ] || [ "$port" -gt 65535 ]; then
        return 1
    fi
    
    return 0
}

# Validate domain name
validate_domain() {
    local domain=$1
    
    # Empty is allowed (optional field)
    if [ -z "$domain" ]; then
        return 0
    fi
    
    # Must not contain protocol
    if [[ "$domain" =~ ^https?:// ]]; then
        return 1
    fi
    
    # Basic domain format
    if [[ "$domain" =~ ^[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$ ]]; then
        return 0
    fi
    
    return 1
}

# Validate PM2 app name
validate_pm2_app_name() {
    local name=$1
    
    if [ -z "$name" ]; then
        return 1
    fi
    
    # Alphanumeric, dash, underscore only
    if ! [[ "$name" =~ ^[a-zA-Z0-9_-]+$ ]]; then
        return 1
    fi
    
    # Max length 64 chars
    if [ ${#name} -gt 64 ]; then
        return 1
    fi
    
    return 0
}

# Test SSH connection (optional)
test_ssh_connection() {
    local user=$1
    local host=$2
    local port=${3:-22}
    
    # Try connection with 5 second timeout
    if ssh -o ConnectTimeout=5 -o BatchMode=yes -p "$port" "$user@$host" "exit" 2>/dev/null; then
        return 0
    fi
    
    return 1
}

# Parse users.yml file
parse_users_yaml() {
    local yaml_file=$1

    if [ ! -f "$yaml_file" ]; then
        error "users.yml not found in current directory"
    fi

    # Extract users using awk (simple YAML parser)
    awk '
    BEGIN { in_users=0; in_user=0; username=""; email=""; password=""; sudo="false"; }

    /^users:/ { in_users=1; next }

    in_users && /^[^ ]/ { in_users=0 }

    in_users && /^  - username:/ {
        if (username != "") {
            print username "|" email "|" password "|" sudo "|" authorized_key "|" authorized_key_file "|" authorized_keys
        }
        username=$3
        email=""
        password=""
        sudo="false"
        authorized_key=""
        authorized_key_file=""
        authorized_keys=""
        in_user=1
        next
    }

    in_user && /^    email:/ { email=$2; next }
    in_user && /^    password:/ {
        password=$2
        gsub(/"/, "", password)
        gsub(/'\''/, "", password)
        next
    }
    in_user && /^    sudo:/ { sudo=$2; next }
    in_user && /^    authorized_key:/ {
        authorized_key=$0
        sub(/^    authorized_key: /, "", authorized_key)
        gsub(/"/, "", authorized_key)
        gsub(/'\''/, "", authorized_key)
        next
    }
    in_user && /^    authorized_key_file:/ {
        authorized_key_file=$2
        gsub(/"/, "", authorized_key_file)
        gsub(/'\''/, "", authorized_key_file)
        next
    }
    in_user && /^    authorized_keys:/ {
        in_authorized_keys=1
        next
    }
    in_authorized_keys && /^      - / {
        key=$0
        sub(/^      - /, "", key)
        gsub(/"/, "", key)
        gsub(/'\''/, "", key)
        if (authorized_keys == "") {
            authorized_keys=key
        } else {
            authorized_keys=authorized_keys ":::" key
        }
        next
    }
    in_authorized_keys && /^    [^ ]/ { in_authorized_keys=0 }

    END {
        if (username != "") {
            print username "|" email "|" password "|" sudo "|" authorized_key "|" authorized_key_file "|" authorized_keys
        }
    }
    ' "$yaml_file"
}

# Core user management functions
create_remote_user() {
    local username=$1
    local email=$2
    local password_hash=$3

    ssh -T -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" bash << ENDSSH
        set -e
        USERNAME="$username"
        PASSWORD_HASH="$password_hash"

        # Detect sudo prefix
        SUDO=""
        if [ "\$EUID" -ne 0 ]; then
            SUDO="sudo"
        fi

        # Check if user exists
        if id "\$USERNAME" &>/dev/null; then
            echo "EXISTS"
            exit 0
        fi

        # Create user
        if [ -n "\$PASSWORD_HASH" ]; then
            \$SUDO useradd -m -s /bin/bash -p "\$PASSWORD_HASH" "\$USERNAME"
            # Force password change on first login (non-fatal if it fails)
            \$SUDO chage -d 0 "\$USERNAME" 2>/dev/null || true
        else
            \$SUDO useradd -m -s /bin/bash "\$USERNAME"
        fi

        echo "CREATED"
ENDSSH
}

setup_user_ssh_dir() {
    local username=$1

    ssh -T -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" bash -s "$username" << 'ENDSSH'
        set -e
        USERNAME=$1

        SUDO=""
        if [ "$EUID" -ne 0 ]; then
            SUDO="sudo"
        fi

        USER_HOME=$($SUDO eval echo ~$USERNAME)
        SSH_DIR="$USER_HOME/.ssh"

        $SUDO mkdir -p "$SSH_DIR"
        $SUDO touch "$SSH_DIR/authorized_keys"
        $SUDO chmod 700 "$SSH_DIR"
        $SUDO chmod 600 "$SSH_DIR/authorized_keys"
        $SUDO chown -R "$USERNAME:$USERNAME" "$SSH_DIR"
ENDSSH
}

add_user_ssh_key() {
    local username=$1
    local ssh_key=$2

    ssh -T -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" bash << ENDSSH
        set -e
        USERNAME="$username"
        SSH_KEY="$ssh_key"

        SUDO=""
        if [ "\$EUID" -ne 0 ]; then
            SUDO="sudo"
        fi

        USER_HOME=\$(\$SUDO eval echo ~\$USERNAME)
        AUTHORIZED_KEYS="\$USER_HOME/.ssh/authorized_keys"

        # Check if key already exists
        if \$SUDO grep -qF "\$SSH_KEY" "\$AUTHORIZED_KEYS" 2>/dev/null; then
            exit 0
        fi

        # Add key
        echo "\$SSH_KEY" | \$SUDO tee -a "\$AUTHORIZED_KEYS" > /dev/null
ENDSSH
}

grant_deploy_permissions() {
    local username=$1

    ssh -T -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" bash -s "$username" "$REMOTE_PATH" << 'ENDSSH'
        set -e
        USERNAME=$1
        REMOTE_PATH=$2

        SUDO=""
        if [ "$EUID" -ne 0 ]; then
            SUDO="sudo"
        fi

        # Create shipnode-deployers group if it doesn't exist
        if ! getent group shipnode-deployers >/dev/null; then
            $SUDO groupadd shipnode-deployers
        fi

        # Add user to group
        $SUDO usermod -aG shipnode-deployers "$USERNAME"

        # Set up ACLs if directory exists
        if [ -d "$REMOTE_PATH" ]; then
            # Install acl if not present
            if ! command -v setfacl &> /dev/null; then
                $SUDO apt-get update -qq
                $SUDO apt-get install -y -qq acl
            fi

            $SUDO setfacl -R -m g:shipnode-deployers:rwx "$REMOTE_PATH" 2>/dev/null || true
            $SUDO setfacl -R -d -m g:shipnode-deployers:rwx "$REMOTE_PATH" 2>/dev/null || true
        fi

        # Create sudoers file for PM2 commands
        if ! [ -f /etc/sudoers.d/shipnode ]; then
            echo "%shipnode-deployers ALL=(ALL) NOPASSWD: /usr/bin/pm2 *" | $SUDO tee /etc/sudoers.d/shipnode > /dev/null
            $SUDO chmod 440 /etc/sudoers.d/shipnode
        fi
ENDSSH
}

grant_sudo_access() {
    local username=$1

    ssh -T -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" bash -s "$username" << 'ENDSSH'
        set -e
        USERNAME=$1

        SUDO=""
        if [ "$EUID" -ne 0 ]; then
            SUDO="sudo"
        fi

        $SUDO usermod -aG sudo "$USERNAME"
ENDSSH
}

revoke_user_access() {
    local username=$1

    ssh -T -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" bash -s "$username" << 'ENDSSH'
        set -e
        USERNAME=$1

        SUDO=""
        if [ "$EUID" -ne 0 ]; then
            SUDO="sudo"
        fi

        # Remove from groups
        $SUDO gpasswd -d "$USERNAME" shipnode-deployers 2>/dev/null || true
        $SUDO gpasswd -d "$USERNAME" sudo 2>/dev/null || true

        # Lock account
        $SUDO usermod -L "$USERNAME"

        # Clear SSH keys
        USER_HOME=$($SUDO eval echo ~$USERNAME)
        if [ -f "$USER_HOME/.ssh/authorized_keys" ]; then
            $SUDO rm -f "$USER_HOME/.ssh/authorized_keys"
        fi
ENDSSH
}

# Command functions
cmd_user_sync() {
    load_config

    local yaml_file="users.yml"

    if [ ! -f "$yaml_file" ]; then
        error "users.yml not found. Create it first with user definitions."
    fi

    info "Syncing users from users.yml..."

    # Ensure .shipnode directory exists
    ssh -T -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" "mkdir -p $REMOTE_PATH/.shipnode"

    # Initialize users.json if it doesn't exist
    ssh -T -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" bash << ENDSSH
        if [ ! -f $REMOTE_PATH/.shipnode/users.json ]; then
            echo '{"users":[]}' > $REMOTE_PATH/.shipnode/users.json
        fi
ENDSSH

    # Parse users.yml
    local users_data=$(parse_users_yaml "$yaml_file")

    if [ -z "$users_data" ]; then
        warn "No users found in users.yml"
        return 0
    fi

    # Process each user
    while IFS='|' read -r username email password sudo authorized_key authorized_key_file authorized_keys; do
        # Validate username
        if ! validate_username "$username"; then
            warn "Invalid username: $username (skipping)"
            continue
        fi

        # Validate email
        if [ -z "$email" ]; then
            warn "No email for user: $username (skipping)"
            continue
        fi

        # Validate password if provided
        if [ -n "$password" ] && ! validate_password_hash "$password"; then
            warn "Invalid password hash for user: $username (skipping)"
            continue
        fi

        # Create user
        local result=$(create_remote_user "$username" "$email" "$password")
        local user_exists=false

        if [ "$result" = "EXISTS" ]; then
            user_exists=true
            info "User exists: $username (updating SSH keys if provided)"
        fi

        local auth_method=""

        # Setup SSH if keys provided
        if [ -n "$authorized_key" ] || [ -n "$authorized_key_file" ] || [ -n "$authorized_keys" ]; then
            setup_user_ssh_dir "$username"
            auth_method="ssh-key"

            # Add inline authorized key
            if [ -n "$authorized_key" ]; then
                if validate_ssh_key "$authorized_key"; then
                    add_user_ssh_key "$username" "$authorized_key"
                else
                    warn "Invalid SSH key for user: $username"
                fi
            fi

            # Add key from file
            if [ -n "$authorized_key_file" ]; then
                local key_content=$(read_key_file "$authorized_key_file")
                if [ -n "$key_content" ] && validate_ssh_key "$key_content"; then
                    add_user_ssh_key "$username" "$key_content"
                else
                    warn "Invalid or missing SSH key file: $authorized_key_file"
                fi
            fi

            # Add multiple keys
            if [ -n "$authorized_keys" ]; then
                IFS=':::' read -ra KEYS <<< "$authorized_keys"
                for key in "${KEYS[@]}"; do
                    if validate_ssh_key "$key"; then
                        add_user_ssh_key "$username" "$key"
                    else
                        warn "Invalid SSH key in authorized_keys for user: $username"
                    fi
                done
            fi
        elif [ -n "$password" ]; then
            auth_method="password"
        else
            warn "User $username has no password or SSH keys (skipping)"
            continue
        fi

        # Skip these steps for existing users
        if [ "$user_exists" = false ]; then
            # Grant deploy permissions
            grant_deploy_permissions "$username"

            # Grant sudo if requested
            if [ "$sudo" = "true" ]; then
                grant_sudo_access "$username"
            fi

            # Record user in users.json
            ssh -T -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" bash << ENDSSH
                cd $REMOTE_PATH/.shipnode
                CURRENT_DATE=\$(date -Is)
                jq ".users += [{\"username\":\"$username\",\"email\":\"$email\",\"auth\":\"$auth_method\",\"sudo\":$sudo,\"created_at\":\"\$CURRENT_DATE\"}]" users.json > users.json.tmp
                mv users.json.tmp users.json
ENDSSH

            # Report creation
            local sudo_msg=""
            [ "$sudo" = "true" ] && sudo_msg=", sudo enabled"

            if [ "$auth_method" = "password" ]; then
                success "Created user: $username (password auth, must change on first login$sudo_msg)"
            else
                success "Created user: $username (SSH key added$sudo_msg)"
            fi
        else
            # Report update for existing user
            success "Updated SSH keys for existing user: $username"
        fi

    done <<< "$users_data"

    success "User sync complete"
}

cmd_user_list() {
    load_config

    info "Listing provisioned users..."

    # Check if users.json exists
    local has_users=$(ssh -T -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" "[ -f $REMOTE_PATH/.shipnode/users.json ] && echo 'yes' || echo 'no'")

    if [ "$has_users" = "no" ]; then
        warn "No users provisioned yet. Run 'shipnode user sync' first."
        return 0
    fi

    # Fetch and display users
    ssh -T -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" bash << ENDSSH
        echo ""
        printf "%-15s %-30s %-12s %-8s %s\n" "USERNAME" "EMAIL" "AUTH" "SUDO" "CREATED"
        echo "==================================================================================="

        cat $REMOTE_PATH/.shipnode/users.json | jq -r '.users[] | "\(.username)|\(.email)|\(.auth)|\(.sudo)|\(.created_at)"' | while IFS='|' read -r username email auth sudo created; do
            # Format created date
            created_short=$(echo "$created" | cut -d'T' -f1)
            sudo_text="no"
            [ "$sudo" = "true" ] && sudo_text="yes"

            printf "%-15s %-30s %-12s %-8s %s\n" "$username" "$email" "$auth" "$sudo_text" "$created_short"
        done

        echo ""
        total=$(cat $REMOTE_PATH/.shipnode/users.json | jq '.users | length')
        echo "Total: $total users"
ENDSSH
}

cmd_user_remove() {
    local username=$1

    if [ -z "$username" ]; then
        error "Usage: shipnode user remove <username>"
    fi

    load_config

    warn "This will revoke access for user: $username"
    read -p "Continue? (y/N) " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        info "Cancelled"
        return 0
    fi

    info "Revoking access for: $username..."

    # Revoke access
    revoke_user_access "$username"

    # Remove from users.json
    ssh -T -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" bash << ENDSSH
        if [ -f $REMOTE_PATH/.shipnode/users.json ]; then
            cd $REMOTE_PATH/.shipnode
            jq ".users = [.users[] | select(.username != \"$username\")]" users.json > users.json.tmp
            mv users.json.tmp users.json
        fi
ENDSSH

    success "Access revoked for: $username"
}

cmd_mkpasswd() {
    # Check if mkpasswd is available
    if ! command -v mkpasswd &> /dev/null; then
        error "mkpasswd not found. Install it with: sudo apt-get install whois"
    fi

    info "Generate password hash for users.yml"
    echo ""

    # Prompt for password (with confirmation)
    read -sp "Enter password: " password
    echo
    read -sp "Confirm password: " password2
    echo

    if [ "$password" != "$password2" ]; then
        error "Passwords do not match"
    fi

    if [ -z "$password" ]; then
        error "Password cannot be empty"
    fi

    # Generate hash
    local hash=$(mkpasswd -m sha-512 "$password")

    echo ""
    success "Password hash generated:"
    echo ""
    echo "$hash"
    echo ""
    info "Add this to users.yml:"
    echo "  password: \"$hash\""
    echo ""
}

# Load configuration
load_config() {
    if [ ! -f "shipnode.conf" ]; then
        error "shipnode.conf not found. Run 'shipnode init' first."
    fi

    info "Loading configuration..."

    # Source the config file with error handling
    set -a
    if ! source shipnode.conf 2>&1; then
        error "Failed to parse shipnode.conf"
    fi
    set +a

    # Validate required variables
    if [ -z "$APP_TYPE" ]; then
        error "APP_TYPE not set in shipnode.conf"
    fi
    if [ -z "$SSH_USER" ]; then
        error "SSH_USER not set in shipnode.conf"
    fi
    if [ -z "$SSH_HOST" ]; then
        error "SSH_HOST not set in shipnode.conf"
    fi
    if [ -z "$REMOTE_PATH" ]; then
        error "REMOTE_PATH not set in shipnode.conf"
    fi

    # Set defaults
    SSH_PORT="${SSH_PORT:-22}"
    ZERO_DOWNTIME="${ZERO_DOWNTIME:-true}"
    KEEP_RELEASES="${KEEP_RELEASES:-5}"
    HEALTH_CHECK_ENABLED="${HEALTH_CHECK_ENABLED:-true}"
    HEALTH_CHECK_PATH="${HEALTH_CHECK_PATH:-/health}"
    HEALTH_CHECK_TIMEOUT="${HEALTH_CHECK_TIMEOUT:-30}"
    HEALTH_CHECK_RETRIES="${HEALTH_CHECK_RETRIES:-3}"

    # Validate APP_TYPE
    if [ "$APP_TYPE" != "backend" ] && [ "$APP_TYPE" != "frontend" ]; then
        error "APP_TYPE must be 'backend' or 'frontend'"
    fi

    # Backend-specific validation
    if [ "$APP_TYPE" = "backend" ]; then
        if [ -z "$PM2_APP_NAME" ]; then
            error "PM2_APP_NAME required for backend apps"
        fi
        if [ -z "$BACKEND_PORT" ]; then
            error "BACKEND_PORT required for backend apps"
        fi
    fi
}

# Interactive users.yml generation
init_users_yaml() {
    local users_data=()

    info "Add deployment users to users.yml"
    echo ""

    while true; do
        local username email auth_method ssh_key password sudo_access

        # Prompt for username
        while true; do
            read -p "Username: " username
            if [ -z "$username" ]; then
                warn "Username cannot be empty"
                continue
            fi
            if ! validate_username "$username"; then
                warn "Invalid username (alphanumeric, dash, underscore, max 32 chars)"
                continue
            fi
            break
        done

        # Prompt for email
        while true; do
            read -p "Email: " email
            if [ -z "$email" ]; then
                warn "Email cannot be empty"
                continue
            fi
            if ! validate_email "$email"; then
                warn "Invalid email address"
                continue
            fi
            break
        done

        # Prompt for auth method
        echo ""
        echo "Authentication method:"
        echo "  1) SSH key"
        echo "  2) Password"
        read -p "Choose (1-2): " -n 1 auth_choice
        echo ""
        echo ""

        case "$auth_choice" in
            1)
                auth_method="ssh"
                # Prompt for SSH public key
                while true; do
                    read -p "SSH public key: " ssh_key
                    if [ -z "$ssh_key" ]; then
                        warn "SSH key cannot be empty"
                        continue
                    fi
                    if ! validate_ssh_key "$ssh_key"; then
                        warn "Invalid SSH key format"
                        continue
                    fi
                    break
                done
                ;;
            2)
                auth_method="password"
                # Prompt for password with confirmation
                while true; do
                    read -sp "Password: " password
                    echo
                    if [ -z "$password" ]; then
                        warn "Password cannot be empty"
                        continue
                    fi
                    read -sp "Confirm password: " password2
                    echo
                    if [ "$password" != "$password2" ]; then
                        warn "Passwords do not match"
                        continue
                    fi
                    break
                done
                ;;
            *)
                warn "Invalid choice, defaulting to SSH key"
                auth_method="ssh"
                while true; do
                    read -p "SSH public key: " ssh_key
                    if [ -z "$ssh_key" ]; then
                        warn "SSH key cannot be empty"
                        continue
                    fi
                    if ! validate_ssh_key "$ssh_key"; then
                        warn "Invalid SSH key format"
                        continue
                    fi
                    break
                done
                ;;
        esac

        # Prompt for sudo access
        sudo_access="false"
        if prompt_yes_no "Grant sudo access?"; then
            sudo_access="true"
        fi

        # Store user data
        users_data+=("$username|$email|$auth_method|$ssh_key|$password|$sudo_access")

        echo ""
        if ! prompt_yes_no "Add another user?"; then
            break
        fi
        echo ""
    done

    # Generate users.yml
    cat > users.yml << 'EOF'
# ShipNode User Configuration
# Sync users to server: shipnode user sync

users:
EOF

    for user_entry in "${users_data[@]}"; do
        IFS='|' read -r username email auth_method ssh_key password sudo_access <<< "$user_entry"

        echo "  - username: $username" >> users.yml
        echo "    email: $email" >> users.yml

        if [ "$auth_method" = "ssh" ]; then
            echo "    authorized_key: \"$ssh_key\"" >> users.yml
        else
            # Generate password hash
            local hash=$(generate_password_hash "$password")
            echo "    password: \"$hash\"" >> users.yml
        fi

        if [ "$sudo_access" = "true" ]; then
            echo "    sudo: true" >> users.yml
        fi

        echo "" >> users.yml
    done

    # Add footer comment
    echo "# Generate password hashes: shipnode mkpasswd" >> users.yml

    success "Created users.yml with ${#users_data[@]} user(s)"
    info "Review users.yml and run: shipnode user sync"
}

# ============================================================================
# INTERACTIVE PROMPT HELPERS
# ============================================================================

# Prompt with default value
prompt_with_default() {
    local prompt=$1
    local default=$2
    local varname=$3
    
    if [ -n "$default" ]; then
        read -p "$prompt [$default]: " input
        printf -v "$varname" '%s' "${input:-$default}"
    else
        read -p "$prompt: " input
        printf -v "$varname" '%s' "$input"
    fi
}

# Prompt with validation loop
prompt_with_validation() {
    local prompt=$1
    local validator=$2
    local varname=$3
    local default=${4:-}
    
    while true; do
        if [ -n "$default" ]; then
            read -p "$prompt [$default]: " input
            input="${input:-$default}"
        else
            read -p "$prompt: " input
        fi
        
        if [ -z "$input" ] && [ -z "$default" ]; then
            warn "This field is required"
            continue
        fi
        
        if $validator "$input"; then
            printf -v "$varname" '%s' "$input"
            break
        else
            warn "Invalid input, please try again"
        fi
    done
}

# =============================================================================
#=============================================================================
# GUM UI WRAPPERS (with fallback)
# ============================================================================

# Enhanced input with Gum (or fallback to classic)
gum_input() {
    local prompt=$1
    local default=${2:-}
    local placeholder=${3:-$default}
    
    if [ "$USE_GUM" = true ]; then
        local value=""
        if [ -n "$default" ]; then
            value=$(gum input --placeholder "$placeholder" --prompt "$prompt: " --value "$default" 2>/dev/null || echo "$default")
        else
            value=$(gum input --placeholder "$placeholder" --prompt "$prompt: " 2>/dev/null || echo "")
        fi
        echo "$value"
    else
        # Fallback to classic bash
        local result
        if [ -n "$default" ]; then
            read -p "$prompt [$default]: " result
            echo "${result:-$default}"
        else
            read -p "$prompt: " result
            echo "$result"
        fi
    fi
}

# Enhanced selection with Gum (or fallback to classic)
gum_choose() {
    local header=$1
    shift
    local options=("$@")
    
    if [ "$USE_GUM" = true ]; then
        gum choose "${options[@]}" --header "$header" --cursor "> " 2>/dev/null || echo "${options[0]}"
    else
        # Fallback to classic bash
        echo "$header"
        local i=1
        for opt in "${options[@]}"; do
            echo "  $i) $opt"
            ((i++))
        done
        read -p "Choose: " choice
        
        # Return the selected option
        if [[ "$choice" =~ ^[0-9]+$ ]] && [ "$choice" -ge 1 ] && [ "$choice" -le "${#options[@]}" ]; then
            echo "${options[$((choice-1))]}"
        else
            echo "${options[0]}"
        fi
    fi
}

# Enhanced confirmation with Gum (or fallback to classic)
gum_confirm() {
    local message=$1
    local default=${2:-y}
    
    if [ "$USE_GUM" = true ]; then
        if [ "$default" = "y" ]; then
            gum confirm "$message" 2>/dev/null && return 0 || return 1
        else
            gum confirm "$message" --default=false 2>/dev/null && return 0 || return 1
        fi
    else
        # Fallback to existing function
        prompt_yes_no "$message" "$default"
    fi
}

# Enhanced styling with Gum (or fallback to classic)
gum_style() {
    local text=$1
    shift
    local args=("$@")
    
    if [ "$USE_GUM" = true ]; then
        gum style "${args[@]}" "$text" 2>/dev/null || echo "$text"
    else
        # Fallback to classic echo
        echo "$text"
    fi
}

# Show informative message about Gum if not installed
show_gum_tip() {
    if [ "$USE_GUM" = false ]; then
        echo ""
        info "ðŸ’¡ Tip: Install gum for enhanced interactive experience"
        echo "   https://github.com/charmbracelet/gum"
        echo ""
    fi
}

# INITIALIZATION COMMANDS
# ============================================================================

# Legacy non-interactive init (backward compatibility)
cmd_init_legacy() {
    if [ -f "shipnode.conf" ]; then
        read -p "shipnode.conf already exists. Overwrite? (y/N) " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            info "Aborted."
            exit 0
        fi
    fi

    cat > shipnode.conf << 'EOF'
# App type: "backend" or "frontend"
APP_TYPE=backend

# SSH Connection
SSH_USER=root
SSH_HOST=your-server-ip
SSH_PORT=22

# Remote path
REMOTE_PATH=/var/www/myapp

# Backend-specific
PM2_APP_NAME=myapp
BACKEND_PORT=3000

# Frontend-specific (optional)
DOMAIN=myapp.com

# Zero-downtime deployment (optional)
ZERO_DOWNTIME=true
KEEP_RELEASES=5

# Health checks for backend (optional)
HEALTH_CHECK_ENABLED=true
HEALTH_CHECK_PATH=/health
HEALTH_CHECK_TIMEOUT=30
HEALTH_CHECK_RETRIES=3
EOF

    success "Created shipnode.conf"
    info "Edit shipnode.conf with your server details, then run: shipnode deploy"

    # Optionally generate users.yml
    echo ""
    if prompt_yes_no "Add deployment users?"; then
        init_users_yaml
    else
        info "Skipped users.yml - create later with 'shipnode user sync'"
    fi
}

# Interactive initialization wizard
cmd_init_interactive() {
    # Check for existing config
    if [ -f "shipnode.conf" ]; then
        warn "shipnode.conf already exists"
        if ! prompt_yes_no "Overwrite?"; then
            info "Aborted"
            return 0
        fi
    fi
    
    # Welcome banner
    echo ""
    if [ "$USE_GUM" = true ]; then
        gum style \
            --border double \
            --border-foreground 212 \
            --align center \
            --width 50 \
            --margin "1 0" \
            --padding "1 2" \
            "ShipNode Interactive Setup" \
            "" \
            "Powered by Gum âœ¨"
    else
        echo -e "${BLUE}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
        echo -e "${BLUE}â•‘  ShipNode Interactive Setup        â•‘${NC}"
        echo -e "${BLUE}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    fi
    echo ""
    
    # Show tip about Gum if not installed
    show_gum_tip
    
    # 1. Framework detection
    local detected_framework detected_type
    IFS='|' read -r detected_framework detected_type <<< "$(detect_framework)"
    
    if [ "$detected_framework" != "none" ]; then
        info "Detected framework: $detected_framework"
        info "Suggested app type: $detected_type"
        echo ""
    fi
    
    # 2. Prompt for app type
    local app_type
    
    if [ "$USE_GUM" = true ]; then
        # Enhanced selection with Gum
        local header="Select application type:"
        if [ "$detected_type" != "unknown" ]; then
            header="Select application type (detected: $detected_type):"
        fi
        
        local selection
        selection=$(gum choose \
            "Backend (Node.js API with PM2)" \
            "Frontend (Static site)" \
            --header "$header" \
            --cursor-prefix "â†’ " \
            --selected-prefix "âœ“ ")
        
        case "$selection" in
            "Backend"*) app_type="backend" ;;
            "Frontend"*) app_type="frontend" ;;
            *) 
                # Default to detected type if available
                if [ "$detected_type" != "unknown" ]; then
                    app_type="$detected_type"
                else
                    app_type="backend"
                fi
                ;;
        esac
    else
        # Classic bash selection
        echo "Application type:"
        echo "  1) Backend (Node.js API with PM2)"
        echo "  2) Frontend (Static site)"
        echo ""
        
        while true; do
            if [ "$detected_type" != "unknown" ]; then
                read -p "Choose [1-2] (detected: $detected_type): " choice
            else
                read -p "Choose [1-2]: " choice
            fi
            
            case "$choice" in
                1|backend) app_type="backend"; break ;;
                2|frontend) app_type="frontend"; break ;;
                "") 
                    if [ "$detected_type" != "unknown" ]; then
                        app_type="$detected_type"
                        break
                    fi
                    warn "Please choose an option"
                    ;;
                *) warn "Invalid choice" ;;
            esac
        done
    fi
    
    # 3. SSH connection details
    echo ""
    info "Server connection details"
    echo "Enter SSH credentials for your deployment server"
    echo ""
    
    local ssh_user ssh_host ssh_port
    echo "  (The SSH user to connect with - typically 'root' or your username)"
    prompt_with_default "SSH user" "root" "ssh_user"
    echo "  (Your server's IP address or domain name - e.g. 192.168.1.100 or server.example.com)"
    prompt_with_validation "SSH host (IP or hostname)" "validate_ip_or_hostname" "ssh_host" ""
    echo "  (SSH port - default is 22)"
    prompt_with_validation "SSH port" "validate_port" "ssh_port" "22"
    
    # 4. Deployment path
    echo ""
    info "Deployment configuration"
    echo ""
    local remote_path app_name
    
    # Try to get app name from package.json
    if [ -f "package.json" ] && command -v jq &> /dev/null; then
        app_name=$(jq -r '.name // empty' package.json 2>/dev/null | sed -E 's/^@[^/]+\/(.*)$/\1/' | tr ' ' '-' | tr -c 'A-Za-z0-9._-' '-' | sed 's/-*$//')
    fi
    
    if [ -z "$app_name" ]; then
        app_name=$(basename "$PWD")
    fi
    
    echo "  (Directory on the server where your app will be deployed)"
    prompt_with_default "Remote deployment path" "/var/www/$app_name" "remote_path"
    
    # 5. Backend-specific config
    local pm2_app_name backend_port domain
    if [ "$app_type" = "backend" ]; then
        echo ""
        info "Backend configuration"
        echo "Configure your Node.js backend application"
        echo ""
        
        pm2_app_name="$app_name"
        prompt_with_validation "PM2 process name" "validate_pm2_app_name" "pm2_app_name" "$app_name"
        
        # Try to detect port
        local suggested_port
        suggested_port=$(suggest_port)
        
        echo "  (Port your Node.js app will listen on - typically 3000, 5000, or 8080)"
        prompt_with_validation "Application port" "validate_port" "backend_port" "${suggested_port:-3000}"
        echo "  (Optional: Your domain name for HTTPS - e.g. api.myapp.com)"
        prompt_with_validation "Domain (optional, press Enter to skip)" "validate_domain" "domain" ""
    fi
    
    # 6. Frontend-specific config
    if [ "$app_type" = "frontend" ]; then
        echo ""
        info "Frontend configuration"
        echo "Configure your static site deployment"
        echo ""
        echo ""
        echo "Note: Domain is required for frontend deployments (needed for Caddy web server)"
        
        while true; do
            echo "  (Your domain name - e.g. myapp.com or www.myapp.com)"
            prompt_with_validation "Domain" "validate_domain" "domain" ""
            if [ -n "$domain" ]; then
                break
            fi
            warn "Domain is required for frontend deployments"
        done
    fi
    
    # Use defaults for advanced options
    local zero_downtime="true"
    local keep_releases="5"
    local health_enabled="true"
    local health_path="/health"
    local health_timeout="30"
    local health_retries="3"
    
    # 7. Configuration summary
    echo ""
    echo -e "${BLUE}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo -e "${BLUE}Configuration Summary${NC}"
    echo -e "${BLUE}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo "App Type:      $app_type"
    echo "SSH:           $ssh_user@$ssh_host:$ssh_port"
    echo "Remote Path:   $remote_path"
    
    if [ "$app_type" = "backend" ]; then
        echo "PM2 Name:      $pm2_app_name"
        echo "Backend Port:  $backend_port"
    fi
    
    [ -n "$domain" ] && echo "Domain:        $domain"
    echo "Zero-downtime: $zero_downtime"
    
    if [ "$app_type" = "backend" ] && [ "$health_enabled" = "true" ]; then
        echo "Health Checks: $health_path (${health_timeout}s timeout, ${health_retries} retries)"
    fi
    
    echo -e "${BLUE}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo ""
    
    if ! prompt_yes_no "Create shipnode.conf with these settings?" "y"; then
        warn "Configuration cancelled"
        return 1
    fi
    
    # 8. Write configuration file
    cat > shipnode.conf <<EOF
# ShipNode Configuration
# Generated by interactive wizard

# Application type
APP_TYPE=$app_type

# SSH Connection
SSH_USER=$ssh_user
SSH_HOST=$ssh_host
SSH_PORT=$ssh_port

# Deployment path
REMOTE_PATH=$remote_path
EOF

    # Backend-specific settings
    if [ "$app_type" = "backend" ]; then
        cat >> shipnode.conf <<EOF

# Backend settings
PM2_APP_NAME=$pm2_app_name
BACKEND_PORT=$backend_port
EOF
    fi

    # Domain (for both types if provided)
    if [ -n "$domain" ]; then
        cat >> shipnode.conf <<EOF

# Domain
DOMAIN=$domain
EOF
    fi

    # Zero-downtime settings
    cat >> shipnode.conf <<EOF

# Zero-downtime deployment
ZERO_DOWNTIME=$zero_downtime
KEEP_RELEASES=$keep_releases
EOF

    # Health check settings (backend only)
    if [ "$app_type" = "backend" ] && [ "$health_enabled" = "true" ]; then
        cat >> shipnode.conf <<EOF

# Health checks
HEALTH_CHECK_ENABLED=$health_enabled
HEALTH_CHECK_PATH=$health_path
HEALTH_CHECK_TIMEOUT=$health_timeout
HEALTH_CHECK_RETRIES=$health_retries
EOF
    fi

    success "Created shipnode.conf"
    
    # 9. Users.yml wizard
    echo ""
    if prompt_yes_no "Add deployment users now?"; then
        init_users_yaml
    else
        info "You can add users later with: shipnode user sync"
    fi
    
    echo ""
    success "Initialization complete!"
    info "Next steps:"
    echo "  1. Review shipnode.conf"
    echo "  2. Run: shipnode setup"
    echo "  3. Run: shipnode deploy"
}

# Initialize config file (router)
cmd_init() {
    if [ "$1" = "--non-interactive" ]; then
        cmd_init_legacy
    else
        cmd_init_interactive
    fi
}

# Setup server (first-time)
cmd_setup() {
    load_config

    info "Setting up server $SSH_USER@$SSH_HOST..."

    # Check SSH connection
    if ! ssh -o ConnectTimeout=10 -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" "exit"; then
        error "Cannot connect to $SSH_USER@$SSH_HOST:$SSH_PORT"
    fi

    success "SSH connection successful"

    # Install Node.js, PM2, and Caddy
    info "Installing dependencies on server..."

    ssh -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" bash << 'ENDSSH'
        set -e

        # Detect if running as root and set sudo prefix
        SUDO=""
        if [ "$EUID" -ne 0 ]; then
            SUDO="sudo"
        fi

        # Install jq for JSON manipulation
        if ! command -v jq &> /dev/null; then
            echo "Installing jq..."
            $SUDO apt-get update
            $SUDO apt-get install -y jq
        else
            echo "jq already installed: $(jq --version)"
        fi

        # Install Node.js (using NodeSource)
        if ! command -v node &> /dev/null; then
            echo "Installing Node.js..."
            curl -fsSL https://deb.nodesource.com/setup_lts.x | $SUDO bash -
            $SUDO apt-get install -y nodejs
        else
            echo "Node.js already installed: $(node --version)"
        fi

        # Install PM2
        if ! command -v pm2 &> /dev/null; then
            echo "Installing PM2..."
            $SUDO npm install -g pm2
            pm2 startup systemd -u $USER --hp $HOME
        else
            echo "PM2 already installed: $(pm2 --version)"
        fi

        # Install Caddy
        if ! command -v caddy &> /dev/null; then
            echo "Installing Caddy..."
            $SUDO apt install -y debian-keyring debian-archive-keyring apt-transport-https curl
            curl -1sLf 'https://dl.cloudsmith.io/public/caddy/stable/gpg.key' | $SUDO gpg --dearmor -o /usr/share/keyrings/caddy-stable-archive-keyring.gpg
            curl -1sLf 'https://dl.cloudsmith.io/public/caddy/stable/debian.deb.txt' | $SUDO tee /etc/apt/sources.list.d/caddy-stable.list
            $SUDO apt update
            $SUDO apt install -y caddy
        else
            echo "Caddy already installed: $(caddy version)"
        fi
ENDSSH

    # Setup PostgreSQL if enabled
    setup_postgresql

    success "Server setup complete"
    info "Ready to deploy with: shipnode deploy"
}

# Deploy application
cmd_deploy() {
    load_config

    local SKIP_BUILD=false
    if [ "$1" = "--skip-build" ]; then
        SKIP_BUILD=true
    fi

    info "Deploying $APP_TYPE to $SSH_USER@$SSH_HOST..."

    # Create remote directory
    ssh -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" "mkdir -p $REMOTE_PATH"

    if [ "$APP_TYPE" = "backend" ]; then
        deploy_backend
    else
        deploy_frontend "$SKIP_BUILD"
    fi
}

deploy_backend() {
    info "Deploying backend application..."

    # Check if package.json exists
    [ ! -f "package.json" ] && error "package.json not found in current directory"

    if [ "$ZERO_DOWNTIME" = "true" ]; then
        deploy_backend_zero_downtime
    else
        deploy_backend_legacy
    fi
}

deploy_backend_legacy() {
    info "Using legacy deployment (non-zero-downtime)..."

    # Rsync application files
    info "Syncing files to server..."
    rsync -avz --progress \
        --exclude 'node_modules' \
        --exclude '.env' \
        --exclude '.git' \
        --exclude '.gitignore' \
        --exclude 'shipnode.conf' \
        --exclude '*.log' \
        -e "ssh -p $SSH_PORT" \
        ./ "$SSH_USER@$SSH_HOST:$REMOTE_PATH/"

    success "Files synced"

    # Install dependencies and start with PM2
    info "Installing dependencies and starting app..."

    ssh -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" bash << ENDSSH
        set -e
        cd $REMOTE_PATH
        npm install --production

        # Start or reload with PM2
        if pm2 describe $PM2_APP_NAME > /dev/null 2>&1; then
            pm2 reload $PM2_APP_NAME
        else
            if [ -f ecosystem.config.js ]; then
                pm2 start ecosystem.config.js
            else
                pm2 start npm --name "$PM2_APP_NAME" -- start
            fi
        fi

        pm2 save
ENDSSH

    success "Backend deployed and running"

    # Optionally configure Caddy
    if [ -n "$DOMAIN" ]; then
        configure_caddy_backend
    fi

    info "Run 'shipnode status' to check app status"
}

deploy_backend_zero_downtime() {
    info "Using zero-downtime deployment..."

    # Acquire deployment lock
    info "Acquiring deployment lock..."
    acquire_deploy_lock
    trap release_deploy_lock EXIT
    success "Lock acquired"

    # Generate release timestamp
    local timestamp=$(generate_release_timestamp)
    local release_path=$(get_release_path "$timestamp")

    info "Creating release: $timestamp"

    # Setup release structure on first deploy
    info "Setting up release structure..."
    setup_release_structure
    success "Release structure ready"

    # Get previous release for potential rollback
    local previous_release=$(get_previous_release)

    # Rsync to new release directory
    info "Syncing files to release directory..."
    rsync -avz --progress \
        --exclude 'node_modules' \
        --exclude '.env' \
        --exclude '.git' \
        --exclude '.gitignore' \
        --exclude 'shipnode.conf' \
        --exclude '*.log' \
        -e "ssh -p $SSH_PORT" \
        ./ "$SSH_USER@$SSH_HOST:$release_path/"

    success "Files synced to $release_path"

    # Link shared resources and install dependencies
    info "Setting up release environment..."
    ssh -T -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" bash << ENDSSH
        set -e
        cd $release_path

        # Link shared .env if it exists
        if [ -f $REMOTE_PATH/shared/.env ]; then
            ln -sf $REMOTE_PATH/shared/.env .env
        fi

        # Install dependencies
        npm install --production
ENDSSH

    success "Release prepared"

    # Atomic symlink switch
    info "Switching to new release..."
    switch_symlink "$release_path"

    # Reload PM2
    info "Reloading application..."
    ssh -T -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" bash << ENDSSH
        set -e
        cd $REMOTE_PATH/current

        if pm2 describe $PM2_APP_NAME > /dev/null 2>&1; then
            pm2 reload $PM2_APP_NAME --update-env
        else
            if [ -f ecosystem.config.js ]; then
                pm2 start ecosystem.config.js
            else
                pm2 start npm --name "$PM2_APP_NAME" -- start
            fi
        fi

        pm2 save
ENDSSH

    # Wait for app to start
    sleep 3

    # Run health check if enabled
    if [ "$HEALTH_CHECK_ENABLED" = "true" ]; then
        if ! perform_health_check; then
            warn "Health check failed, rolling back..."
            if [ -n "$previous_release" ]; then
                rollback_to_release "$previous_release"
                record_release "$timestamp" "failed"
                error "Deployment failed, rolled back to $previous_release"
            else
                error "Health check failed and no previous release to rollback to"
            fi
        fi
    fi

    # Record successful release
    record_release "$timestamp" "success"
    success "Release $timestamp deployed successfully"

    # Cleanup old releases
    cleanup_old_releases

    # Configure Caddy if needed
    if [ -n "$DOMAIN" ]; then
        configure_caddy_backend
    fi

    info "Run 'shipnode status' to check app status"
}

deploy_frontend() {
    local SKIP_BUILD=$1
    info "Deploying frontend application..."

    # Build if package.json exists and not skipping
    if [ -f "package.json" ] && [ "$SKIP_BUILD" = false ]; then
        info "Building frontend..."
        npm run build || error "Build failed"
        success "Build complete"
    fi

    # Determine build directory
    local BUILD_DIR="dist"
    if [ -d "build" ]; then
        BUILD_DIR="build"
    elif [ -d "public" ]; then
        BUILD_DIR="public"
    fi

    [ ! -d "$BUILD_DIR" ] && error "$BUILD_DIR directory not found"

    if [ "$ZERO_DOWNTIME" = "true" ]; then
        deploy_frontend_zero_downtime "$BUILD_DIR"
    else
        deploy_frontend_legacy "$BUILD_DIR"
    fi
}

deploy_frontend_legacy() {
    local BUILD_DIR=$1

    # Rsync build directory
    info "Syncing $BUILD_DIR to server..."
    rsync -avz --progress --delete \
        -e "ssh -p $SSH_PORT" \
        "$BUILD_DIR/" "$SSH_USER@$SSH_HOST:$REMOTE_PATH/"

    success "Frontend deployed"

    # Configure Caddy
    if [ -n "$DOMAIN" ]; then
        configure_caddy_frontend
    else
        warn "No DOMAIN set. Configure Caddy manually to serve $REMOTE_PATH"
    fi
}

deploy_frontend_zero_downtime() {
    local BUILD_DIR=$1

    info "Using zero-downtime deployment..."

    # Acquire deployment lock
    acquire_deploy_lock
    trap release_deploy_lock EXIT

    # Generate release timestamp
    local timestamp=$(generate_release_timestamp)
    local release_path=$(get_release_path "$timestamp")

    info "Creating release: $timestamp"

    # Setup release structure
    setup_release_structure

    # Rsync build output to release directory
    info "Syncing $BUILD_DIR to release directory..."
    rsync -avz --progress --delete \
        -e "ssh -p $SSH_PORT" \
        "$BUILD_DIR/" "$SSH_USER@$SSH_HOST:$release_path/"

    success "Files synced to $release_path"

    # Atomic symlink switch
    info "Switching to new release..."
    switch_symlink "$release_path"

    # Record release
    record_release "$timestamp" "success"
    success "Release $timestamp deployed successfully"

    # Cleanup old releases
    cleanup_old_releases

    # Configure Caddy
    if [ -n "$DOMAIN" ]; then
        configure_caddy_frontend
    else
        warn "No DOMAIN set. Configure Caddy manually to serve $REMOTE_PATH/current"
    fi
}

configure_caddy_backend() {
    info "Configuring Caddy reverse proxy for $DOMAIN..."

    local CADDY_CONFIG="/etc/caddy/Caddyfile"

    ssh -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" bash << ENDSSH
        set -e

        # Backup existing Caddyfile
        [ -f $CADDY_CONFIG ] && cp $CADDY_CONFIG ${CADDY_CONFIG}.backup

        # Create Caddyfile
        cat > $CADDY_CONFIG << 'EOF'
$DOMAIN {
    reverse_proxy localhost:$BACKEND_PORT
    encode gzip

    log {
        output file /var/log/caddy/${PM2_APP_NAME}.log
    }
}
EOF

        # Reload Caddy
        caddy reload --config $CADDY_CONFIG
ENDSSH

    success "Caddy configured for $DOMAIN â†’ localhost:$BACKEND_PORT"
}

configure_caddy_frontend() {
    info "Configuring Caddy static file server for $DOMAIN..."

    local CADDY_CONFIG="/etc/caddy/Caddyfile"
    local SERVE_PATH="$REMOTE_PATH"

    # Use current symlink if zero-downtime is enabled
    if [ "$ZERO_DOWNTIME" = "true" ]; then
        SERVE_PATH="$REMOTE_PATH/current"
    fi

    ssh -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" bash << ENDSSH
        set -e

        # Backup existing Caddyfile
        [ -f $CADDY_CONFIG ] && cp $CADDY_CONFIG ${CADDY_CONFIG}.backup

        # Create Caddyfile
        cat > $CADDY_CONFIG << 'EOF'
$DOMAIN {
    root * $SERVE_PATH
    file_server
    encode gzip

    try_files {path} /index.html

    log {
        output file /var/log/caddy/frontend.log
    }
}
EOF

        # Reload Caddy
        caddy reload --config $CADDY_CONFIG
ENDSSH

    success "Caddy configured for $DOMAIN â†’ $SERVE_PATH"
}

# Show app status
cmd_status() {
    load_config

    if [ "$APP_TYPE" = "backend" ]; then
        info "Checking PM2 status for $PM2_APP_NAME..."
        ssh -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" "pm2 status $PM2_APP_NAME"
    else
        info "Checking frontend files..."
        ssh -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" "ls -lh $REMOTE_PATH | head -20"
    fi
}

# View logs (backend only)
cmd_logs() {
    load_config

    if [ "$APP_TYPE" != "backend" ]; then
        error "Logs command only available for backend apps"
    fi

    info "Streaming logs for $PM2_APP_NAME (Ctrl+C to exit)..."
    ssh -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" "pm2 logs $PM2_APP_NAME"
}

# Restart app (backend only)
cmd_restart() {
    load_config

    if [ "$APP_TYPE" != "backend" ]; then
        error "Restart command only available for backend apps"
    fi

    info "Restarting $PM2_APP_NAME..."
    ssh -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" "pm2 restart $PM2_APP_NAME"
    success "App restarted"
}

# Stop app (backend only)
cmd_stop() {
    load_config

    if [ "$APP_TYPE" != "backend" ]; then
        error "Stop command only available for backend apps"
    fi

    info "Stopping $PM2_APP_NAME..."
    ssh -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" "pm2 stop $PM2_APP_NAME"
    success "App stopped"
}

# Clear deployment lock
cmd_unlock() {
    load_config

    info "Checking for deployment lock on $SSH_USER@$SSH_HOST..."

    local lock_info
    lock_info=$(ssh -T -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" bash -s "$REMOTE_PATH" << 'ENDSSH'
        REMOTE_PATH="$1"
        LOCK_FILE="$REMOTE_PATH/.shipnode/deploy.lock"

        if [ -f "$LOCK_FILE" ]; then
            LOCK_AGE=$(( $(date +%s) - $(stat -c %Y "$LOCK_FILE") ))
            echo "FOUND:${LOCK_AGE}"
        else
            echo "NOTFOUND"
        fi
ENDSSH
    )

    if [[ "$lock_info" == "NOTFOUND" ]]; then
        info "No deployment lock found"
        return 0
    fi

    local lock_age
    lock_age=$(echo "$lock_info" | cut -d: -f2)

    warn "Found deployment lock (age: ${lock_age}s)"
    read -p "Clear this lock? (y/N) " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        info "Lock not cleared"
        return 0
    fi

    ssh -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" "rm -f $REMOTE_PATH/.shipnode/deploy.lock"
    success "Deployment lock cleared"
}

# Rollback to previous release
cmd_rollback() {
    load_config

    if [ "$ZERO_DOWNTIME" != "true" ]; then
        error "Rollback only available with zero-downtime deployment enabled"
    fi

    local steps_back=${1:-1}

    info "Fetching release history..."

    # Get target release
    local target_release=$(ssh -T -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" bash << ENDSSH
        cd $REMOTE_PATH/.shipnode
        cat releases.json | jq -r ".[-$((steps_back + 1))].timestamp // empty"
ENDSSH
)

    if [ -z "$target_release" ]; then
        error "No release found to rollback to (requested $steps_back steps back)"
    fi

    # Confirm rollback
    warn "This will rollback to release: $target_release"
    read -p "Continue? (y/N) " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        info "Rollback cancelled"
        exit 0
    fi

    # Perform rollback
    rollback_to_release "$target_release"

    # Run health check for backend
    if [ "$APP_TYPE" = "backend" ] && [ "$HEALTH_CHECK_ENABLED" = "true" ]; then
        sleep 3
        if perform_health_check; then
            success "Rollback successful and health check passed"
        else
            warn "Rollback completed but health check failed"
        fi
    else
        success "Rollback successful"
    fi
}

# List available releases
cmd_releases() {
    load_config

    if [ "$ZERO_DOWNTIME" != "true" ]; then
        error "Releases command only available with zero-downtime deployment enabled"
    fi

    info "Fetching releases..."

    ssh -T -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" bash << ENDSSH
        cd $REMOTE_PATH

        # Get current release
        CURRENT=""
        if [ -L current ]; then
            CURRENT=\$(readlink current | xargs basename)
        fi

        echo ""
        echo "Available releases:"
        echo "==================="

        cd .shipnode
        cat releases.json | jq -r '.[] | "\(.timestamp) - \(.date) - \(.status)"' | while read line; do
            timestamp=\$(echo \$line | cut -d' ' -f1)
            if [ "\$timestamp" = "\$CURRENT" ]; then
                echo "â†’ \$line (current)"
            else
                echo "  \$line"
            fi
        done

        echo ""
        echo "Total: \$(cat releases.json | jq 'length') releases"
ENDSSH
}

# Migrate existing deployment to release structure
cmd_migrate() {
    load_config

    if [ "$ZERO_DOWNTIME" != "true" ]; then
        error "Migration only needed when enabling zero-downtime deployment"
    fi

    warn "This will migrate your existing deployment to the release structure"
    warn "Existing files will be moved to a new release directory"
    read -p "Continue? (y/N) " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        info "Migration cancelled"
        exit 0
    fi

    info "Migrating to release structure..."

    local timestamp=$(generate_release_timestamp)

    ssh -T -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" bash << ENDSSH
        set -e
        cd $REMOTE_PATH

        # Create structure
        mkdir -p releases shared .shipnode
        echo "[]" > .shipnode/releases.json

        # Move existing files to first release
        mkdir -p releases/$timestamp

        # Move all files except the new directories
        find . -maxdepth 1 -mindepth 1 \
            ! -name 'releases' \
            ! -name 'shared' \
            ! -name '.shipnode' \
            ! -name 'current' \
            -exec mv {} releases/$timestamp/ \;

        # Move .env to shared if it exists
        if [ -f releases/$timestamp/.env ]; then
            mv releases/$timestamp/.env shared/.env
            ln -sf $REMOTE_PATH/shared/.env releases/$timestamp/.env
        fi

        # Create current symlink
        ln -sfn releases/$timestamp current

        # Update PM2 to use current directory if backend
        if [ "$APP_TYPE" = "backend" ]; then
            cd current
            if pm2 describe $PM2_APP_NAME > /dev/null 2>&1; then
                pm2 delete $PM2_APP_NAME
                if [ -f ecosystem.config.js ]; then
                    pm2 start ecosystem.config.js
                else
                    pm2 start npm --name "$PM2_APP_NAME" -- start
                fi
                pm2 save
            fi
        fi

        # Record initial release
        CURRENT_DATE=\$(date -Is)
        jq ". + [{\"timestamp\":\"$timestamp\",\"date\":\"\$CURRENT_DATE\",\"status\":\"migrated\"}]" .shipnode/releases.json > .shipnode/releases.json.tmp
        mv .shipnode/releases.json.tmp .shipnode/releases.json
ENDSSH

    success "Migration complete"
    info "Your deployment now uses the release structure"
    info "Current release: $timestamp"

    # Update Caddy config
    if [ -n "$DOMAIN" ]; then
        info "Updating Caddy configuration..."
        if [ "$APP_TYPE" = "backend" ]; then
            configure_caddy_backend
        else
            configure_caddy_frontend
        fi
    fi
}

# Upload .env file to server
cmd_env() {
    load_config

    # Check if .env file exists locally
    if [ ! -f .env ]; then
        error ".env file not found in current directory"
    fi

    info "Uploading .env file to server..."

    # Determine target path based on deployment mode
    if [ "$ZERO_DOWNTIME" = "true" ]; then
        # Upload to shared directory for zero-downtime deployments
        TARGET_PATH="$REMOTE_PATH/shared/.env"
        ssh -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" "mkdir -p $REMOTE_PATH/shared"
    else
        # Upload directly to app directory for legacy deployments
        TARGET_PATH="$REMOTE_PATH/.env"
        ssh -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" "mkdir -p $REMOTE_PATH"
    fi

    # Upload the .env file
    scp -P "$SSH_PORT" .env "$SSH_USER@$SSH_HOST:$TARGET_PATH"

    success ".env file uploaded to $TARGET_PATH"

    # Restart backend app if running to reload env vars
    if [ "$APP_TYPE" = "backend" ]; then
        info "Restarting app to reload environment variables..."
        if ssh -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" "pm2 describe $PM2_APP_NAME" &> /dev/null; then
            ssh -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" "pm2 reload $PM2_APP_NAME"
            success "App restarted with new environment variables"
        else
            warn "App not running. Environment variables will be loaded on next deploy."
        fi
    fi
}

# Show help
cmd_help() {
    cat << EOF
ShipNode v$VERSION - Simple Node.js Deployment Tool

Usage: shipnode <command> [options]

Commands:
    init                     Create shipnode.conf (interactive wizard)
    init --non-interactive   Create basic shipnode.conf without prompts
    setup                    First-time server setup (Node, PM2, Caddy, jq)
    deploy              Deploy the application
    deploy --skip-build Deploy without running build step
    env                 Upload .env file to server
    status              Check application status
    logs                View application logs (backend only)
    restart             Restart application (backend only)
    stop                Stop application (backend only)
    unlock              Clear deployment lock (if stuck)
    rollback [N]        Rollback to previous release (or N steps back)
    releases            List all available releases
    migrate             Migrate existing deployment to release structure
    help                Show this help message

User Management:
    user sync           Sync users from users.yml to server
    user list           List all provisioned users
    user remove <user>  Revoke access for a specific user
    mkpasswd            Generate password hash for users.yml

Configuration:
    Edit shipnode.conf to configure your deployment settings.
    Supports both backend (Node.js + PM2) and frontend (static files) apps.

Zero-Downtime Deployment:
    ZERO_DOWNTIME=true           Enable atomic deployments (default)
    KEEP_RELEASES=5              Number of releases to keep (default: 5)
    HEALTH_CHECK_ENABLED=true    Enable health checks (default: true)
    HEALTH_CHECK_PATH=/health    Health endpoint (default: /health)
    HEALTH_CHECK_TIMEOUT=30      Health check timeout seconds (default: 30)
    HEALTH_CHECK_RETRIES=3       Number of health check retries (default: 3)

User Provisioning:
    Create users.yml with user definitions, then run 'shipnode user sync'.
    Generate password hashes with 'shipnode mkpasswd'.

Examples:
    shipnode init               # Create config file
    shipnode setup              # Setup server (first time)
    shipnode deploy             # Deploy your app
    shipnode env                # Upload .env file to server
    shipnode unlock             # Clear stuck deployment lock
    shipnode rollback           # Rollback to previous release
    shipnode rollback 2         # Rollback 2 releases back
    shipnode releases           # List all releases
    shipnode migrate            # Migrate to release structure
    shipnode mkpasswd           # Generate password hash
    shipnode user sync          # Provision users from users.yml
    shipnode user list          # List provisioned users
    shipnode user remove alice  # Revoke access for alice

EOF
}

# Main command dispatcher
main() {
    case "${1:-}" in
        init)
            cmd_init "$2"
            ;;
        setup)
            cmd_setup
            ;;
        deploy)
            cmd_deploy "$2"
            ;;
        env)
            cmd_env
            ;;
        status)
            cmd_status
            ;;
        logs)
            cmd_logs
            ;;
        restart)
            cmd_restart
            ;;
        stop)
            cmd_stop
            ;;
        unlock)
            cmd_unlock
            ;;
        rollback)
            cmd_rollback "$2"
            ;;
        releases)
            cmd_releases
            ;;
        migrate)
            cmd_migrate
            ;;
        user)
            case "${2:-}" in
                sync)
                    cmd_user_sync
                    ;;
                list)
                    cmd_user_list
                    ;;
                remove)
                    cmd_user_remove "$3"
                    ;;
                *)
                    error "Unknown user command: ${2:-}\nAvailable: sync, list, remove"
                    ;;
            esac
            ;;
        mkpasswd)
            cmd_mkpasswd
            ;;
        help|--help|-h)
            cmd_help
            ;;
        "")
            cmd_help
            ;;
        *)
            error "Unknown command: $1\nRun 'shipnode help' for usage."
            ;;
    esac
}

main "$@"
