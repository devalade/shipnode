#!/usr/bin/env bash

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# ShipNode version
VERSION="1.1.0"

# Helper functions
error() {
    echo -e "${RED}Error: $1${NC}" >&2
    exit 1
}

success() {
    echo -e "${GREEN}✓ $1${NC}"
}

info() {
    echo -e "${BLUE}→ $1${NC}"
}

warn() {
    echo -e "${YELLOW}⚠ $1${NC}"
}

# Release management helper functions
generate_release_timestamp() {
    date +"%Y%m%d%H%M%S"
}

get_release_path() {
    local timestamp=$1
    echo "$REMOTE_PATH/releases/$timestamp"
}

setup_release_structure() {
    ssh -T -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" bash << ENDSSH
        mkdir -p $REMOTE_PATH/{releases,shared,.shipnode}
        if [ ! -f $REMOTE_PATH/.shipnode/releases.json ]; then
            echo "[]" > $REMOTE_PATH/.shipnode/releases.json
        fi
ENDSSH
}

acquire_deploy_lock() {
    local result
    result=$(ssh -T -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" bash -s "$REMOTE_PATH" << 'ENDSSH'
        REMOTE_PATH="$1"
        mkdir -p "$REMOTE_PATH/.shipnode"
        LOCK_FILE="$REMOTE_PATH/.shipnode/deploy.lock"

        # Check for stale lock (older than 30 minutes)
        if [ -f "$LOCK_FILE" ]; then
            LOCK_AGE=$(( $(date +%s) - $(stat -c %Y "$LOCK_FILE") ))
            if [ "$LOCK_AGE" -gt 1800 ]; then
                echo "Removing stale lock file (${LOCK_AGE}s old)"
                rm -f "$LOCK_FILE"
            else
                echo "ERROR: Deployment in progress (lock age: ${LOCK_AGE}s)"
                exit 1
            fi
        fi

        # Create lock with timestamp
        date +%s > "$LOCK_FILE"
        echo "Lock acquired"
ENDSSH
    )
    echo "$result"
    if [[ "$result" == *"ERROR"* ]]; then
        error "Failed to acquire deployment lock"
    fi
}

release_deploy_lock() {
    ssh -T -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" "rm -f $REMOTE_PATH/.shipnode/deploy.lock" || true
}

switch_symlink() {
    local release_path=$1
    ssh -T -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" bash << ENDSSH
        cd $REMOTE_PATH
        ln -sfn $release_path current.tmp
        mv -Tf current.tmp current
ENDSSH
}

perform_health_check() {
    local max_retries=${HEALTH_CHECK_RETRIES:-3}
    local timeout=${HEALTH_CHECK_TIMEOUT:-30}
    local path=${HEALTH_CHECK_PATH:-/health}
    local port=${BACKEND_PORT:-3000}

    info "Running health check (${max_retries} retries, ${timeout}s timeout)..."

    for i in $(seq 1 $max_retries); do
        if ssh -T -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" "timeout $timeout curl -sf http://localhost:$port$path" > /dev/null 2>&1; then
            success "Health check passed"
            return 0
        fi
        [ $i -lt $max_retries ] && warn "Health check attempt $i failed, retrying..."
        sleep 2
    done

    error "Health check failed after $max_retries attempts"
    return 1
}

record_release() {
    local timestamp=$1
    local status=$2
    ssh -T -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" bash << ENDSSH
        cd $REMOTE_PATH/.shipnode
        CURRENT_DATE=\$(date -Is)
        jq ". + [{\"timestamp\":\"$timestamp\",\"date\":\"\$CURRENT_DATE\",\"status\":\"$status\"}]" releases.json > releases.json.tmp
        mv releases.json.tmp releases.json
ENDSSH
}

get_previous_release() {
    ssh -T -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" bash << ENDSSH
        cd $REMOTE_PATH/.shipnode
        cat releases.json | jq -r '.[-2].timestamp // empty'
ENDSSH
}

cleanup_old_releases() {
    local keep=${KEEP_RELEASES:-5}
    ssh -T -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" bash << ENDSSH
        cd $REMOTE_PATH/releases
        ls -t | tail -n +$((keep + 1)) | xargs -r rm -rf
ENDSSH
    info "Cleaned up old releases (keeping last $keep)"
}

rollback_to_release() {
    local timestamp=$1
    local release_path="$REMOTE_PATH/releases/$timestamp"

    info "Rolling back to release $timestamp..."
    switch_symlink "$release_path"

    if [ "$APP_TYPE" = "backend" ]; then
        ssh -T -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" "pm2 reload $PM2_APP_NAME"
    fi

    success "Rolled back to $timestamp"
}

# Setup PostgreSQL database
setup_postgresql() {
    # Check if PostgreSQL setup is enabled
    if [ "${DB_SETUP_ENABLED:-false}" != "true" ]; then
        return 0
    fi

    # Validate required variables
    if [ -z "$DB_NAME" ] || [ -z "$DB_USER" ] || [ -z "$DB_PASSWORD" ]; then
        warn "PostgreSQL setup enabled but DB_NAME, DB_USER, or DB_PASSWORD not set in config"
        return 1
    fi

    info "Setting up PostgreSQL..."

    ssh -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" \
        DB_NAME="$DB_NAME" \
        DB_USER="$DB_USER" \
        DB_PASSWORD="$DB_PASSWORD" \
        bash << 'ENDSSH'
        set -e

        # Detect if running as root and set sudo prefix
        SUDO=""
        if [ "$EUID" -ne 0 ]; then
            SUDO="sudo"
        fi

        # Install PostgreSQL
        if ! command -v psql &> /dev/null; then
            echo "Installing PostgreSQL..."
            $SUDO apt-get update
            $SUDO apt-get install -y postgresql postgresql-contrib
        else
            echo "PostgreSQL already installed: $(psql --version)"
        fi

        # Ensure PostgreSQL is running
        $SUDO systemctl start postgresql
        $SUDO systemctl enable postgresql

        # Create database and user
        echo "Creating database '$DB_NAME' and user '$DB_USER'..."

        # Create database if it doesn't exist
        $SUDO -u postgres psql -tc "SELECT 1 FROM pg_database WHERE datname = '$DB_NAME'" | grep -q 1 || \
            $SUDO -u postgres psql -c "CREATE DATABASE \"$DB_NAME\";"

        # Create user if it doesn't exist
        $SUDO -u postgres psql -tc "SELECT 1 FROM pg_user WHERE usename = '$DB_USER'" | grep -q 1 || \
            $SUDO -u postgres psql -c "CREATE USER \"$DB_USER\" WITH PASSWORD '$DB_PASSWORD';"

        # Update password if user already exists
        $SUDO -u postgres psql -c "ALTER USER \"$DB_USER\" WITH PASSWORD '$DB_PASSWORD';"

        # Grant privileges
        $SUDO -u postgres psql -c "GRANT ALL PRIVILEGES ON DATABASE \"$DB_NAME\" TO \"$DB_USER\";"

        # For PostgreSQL 15+, grant schema privileges
        $SUDO -u postgres psql -d "$DB_NAME" -c "GRANT ALL ON SCHEMA public TO \"$DB_USER\";" 2>/dev/null || true
        $SUDO -u postgres psql -d "$DB_NAME" -c "GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO \"$DB_USER\";" 2>/dev/null || true
        $SUDO -u postgres psql -d "$DB_NAME" -c "GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO \"$DB_USER\";" 2>/dev/null || true

        echo "PostgreSQL setup complete. Database '$DB_NAME' is ready."
        echo "Connection string: postgresql://$DB_USER:[password]@localhost:5432/$DB_NAME"
ENDSSH

    success "PostgreSQL database '$DB_NAME' configured"
}

# ============================================================================
# USER PROVISIONING FUNCTIONS
# ============================================================================

# Validation helpers
validate_username() {
    local username=$1
    if [[ ! "$username" =~ ^[a-zA-Z0-9_-]+$ ]] || [ ${#username} -gt 32 ]; then
        return 1
    fi
    return 0
}

validate_password_hash() {
    local hash=$1
    # Check if it's a valid crypt format (starts with $)
    if [[ "$hash" =~ ^\$[0-9]+\$ ]]; then
        return 0
    fi
    return 1
}

validate_ssh_key() {
    local key=$1
    # Check if key starts with valid key type
    if [[ "$key" =~ ^(ssh-rsa|ssh-ed25519|ecdsa-sha2-nistp256|ecdsa-sha2-nistp384|ecdsa-sha2-nistp521)\ .+ ]]; then
        return 0
    fi
    return 1
}

# Reusable yes/no prompt with default support
prompt_yes_no() {
    local prompt=$1 default=${2:-n}
    if [ "$default" = "y" ]; then
        read -p "$prompt (Y/n) " -n 1 -r
    else
        read -p "$prompt (y/N) " -n 1 -r
    fi
    echo
    [ -z "$REPLY" ] && { [ "$default" = "y" ] && return 0 || return 1; }
    [[ $REPLY =~ ^[Yy]$ ]]
}

# Generate password hash (reuses cmd_mkpasswd logic)
generate_password_hash() {
    local password=$1
    # Check if mkpasswd is available
    if ! command -v mkpasswd &> /dev/null; then
        error "mkpasswd not found. Install it with: sudo apt-get install whois"
    fi
    mkpasswd -m sha-512 "$password"
}

# Validate email address
validate_email() {
    local email=$1
    if [[ "$email" =~ ^[^@]+@[^@]+\.[^@]+$ ]]; then
        return 0
    fi
    return 1
}

# Read SSH key from file
read_key_file() {
    local file_path=$1
    # Expand tilde to home directory
    file_path="${file_path/#\~/$HOME}"

    if [ ! -f "$file_path" ]; then
        echo ""
        return 1
    fi

    cat "$file_path"
    return 0
}

# Parse users.yml file
parse_users_yaml() {
    local yaml_file=$1

    if [ ! -f "$yaml_file" ]; then
        error "users.yml not found in current directory"
    fi

    # Extract users using awk (simple YAML parser)
    awk '
    BEGIN { in_users=0; in_user=0; username=""; email=""; password=""; sudo="false"; }

    /^users:/ { in_users=1; next }

    in_users && /^[^ ]/ { in_users=0 }

    in_users && /^  - username:/ {
        if (username != "") {
            print username "|" email "|" password "|" sudo "|" public_key "|" public_key_file "|" public_keys
        }
        username=$3
        email=""
        password=""
        sudo="false"
        public_key=""
        public_key_file=""
        public_keys=""
        in_user=1
        next
    }

    in_user && /^    email:/ { email=$2; next }
    in_user && /^    password:/ {
        password=$2
        gsub(/"/, "", password)
        gsub(/'\''/, "", password)
        next
    }
    in_user && /^    sudo:/ { sudo=$2; next }
    in_user && /^    public_key:/ {
        public_key=$0
        sub(/^    public_key: /, "", public_key)
        gsub(/"/, "", public_key)
        gsub(/'\''/, "", public_key)
        next
    }
    in_user && /^    public_key_file:/ {
        public_key_file=$2
        gsub(/"/, "", public_key_file)
        gsub(/'\''/, "", public_key_file)
        next
    }
    in_user && /^    public_keys:/ {
        in_public_keys=1
        next
    }
    in_public_keys && /^      - / {
        key=$0
        sub(/^      - /, "", key)
        gsub(/"/, "", key)
        gsub(/'\''/, "", key)
        if (public_keys == "") {
            public_keys=key
        } else {
            public_keys=public_keys ":::" key
        }
        next
    }
    in_public_keys && /^    [^ ]/ { in_public_keys=0 }

    END {
        if (username != "") {
            print username "|" email "|" password "|" sudo "|" public_key "|" public_key_file "|" public_keys
        }
    }
    ' "$yaml_file"
}

# Core user management functions
create_remote_user() {
    local username=$1
    local email=$2
    local password_hash=$3

    ssh -T -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" bash -s "$username" "$password_hash" << 'ENDSSH'
        set -e
        USERNAME=$1
        PASSWORD_HASH=$2

        # Detect sudo prefix
        SUDO=""
        if [ "$EUID" -ne 0 ]; then
            SUDO="sudo"
        fi

        # Check if user exists
        if id "$USERNAME" &>/dev/null; then
            echo "EXISTS"
            exit 0
        fi

        # Create user
        if [ -n "$PASSWORD_HASH" ]; then
            $SUDO useradd -m -s /bin/bash -p "$PASSWORD_HASH" "$USERNAME"
            # Force password change on first login
            $SUDO chage -d 0 "$USERNAME"
        else
            $SUDO useradd -m -s /bin/bash "$USERNAME"
        fi

        echo "CREATED"
ENDSSH
}

setup_user_ssh_dir() {
    local username=$1

    ssh -T -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" bash -s "$username" << 'ENDSSH'
        set -e
        USERNAME=$1

        SUDO=""
        if [ "$EUID" -ne 0 ]; then
            SUDO="sudo"
        fi

        USER_HOME=$($SUDO eval echo ~$USERNAME)
        SSH_DIR="$USER_HOME/.ssh"

        $SUDO mkdir -p "$SSH_DIR"
        $SUDO touch "$SSH_DIR/authorized_keys"
        $SUDO chmod 700 "$SSH_DIR"
        $SUDO chmod 600 "$SSH_DIR/authorized_keys"
        $SUDO chown -R "$USERNAME:$USERNAME" "$SSH_DIR"
ENDSSH
}

add_user_ssh_key() {
    local username=$1
    local ssh_key=$2

    ssh -T -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" bash -s "$username" "$ssh_key" << 'ENDSSH'
        set -e
        USERNAME=$1
        SSH_KEY=$2

        SUDO=""
        if [ "$EUID" -ne 0 ]; then
            SUDO="sudo"
        fi

        USER_HOME=$($SUDO eval echo ~$USERNAME)
        AUTHORIZED_KEYS="$USER_HOME/.ssh/authorized_keys"

        # Check if key already exists
        if $SUDO grep -qF "$SSH_KEY" "$AUTHORIZED_KEYS" 2>/dev/null; then
            exit 0
        fi

        # Add key
        echo "$SSH_KEY" | $SUDO tee -a "$AUTHORIZED_KEYS" > /dev/null
ENDSSH
}

grant_deploy_permissions() {
    local username=$1

    ssh -T -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" bash -s "$username" "$REMOTE_PATH" << 'ENDSSH'
        set -e
        USERNAME=$1
        REMOTE_PATH=$2

        SUDO=""
        if [ "$EUID" -ne 0 ]; then
            SUDO="sudo"
        fi

        # Create shipnode-deployers group if it doesn't exist
        if ! getent group shipnode-deployers >/dev/null; then
            $SUDO groupadd shipnode-deployers
        fi

        # Add user to group
        $SUDO usermod -aG shipnode-deployers "$USERNAME"

        # Set up ACLs if directory exists
        if [ -d "$REMOTE_PATH" ]; then
            # Install acl if not present
            if ! command -v setfacl &> /dev/null; then
                $SUDO apt-get update -qq
                $SUDO apt-get install -y -qq acl
            fi

            $SUDO setfacl -R -m g:shipnode-deployers:rwx "$REMOTE_PATH" 2>/dev/null || true
            $SUDO setfacl -R -d -m g:shipnode-deployers:rwx "$REMOTE_PATH" 2>/dev/null || true
        fi

        # Create sudoers file for PM2 commands
        if ! [ -f /etc/sudoers.d/shipnode ]; then
            echo "%shipnode-deployers ALL=(ALL) NOPASSWD: /usr/bin/pm2 *" | $SUDO tee /etc/sudoers.d/shipnode > /dev/null
            $SUDO chmod 440 /etc/sudoers.d/shipnode
        fi
ENDSSH
}

grant_sudo_access() {
    local username=$1

    ssh -T -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" bash -s "$username" << 'ENDSSH'
        set -e
        USERNAME=$1

        SUDO=""
        if [ "$EUID" -ne 0 ]; then
            SUDO="sudo"
        fi

        $SUDO usermod -aG sudo "$USERNAME"
ENDSSH
}

revoke_user_access() {
    local username=$1

    ssh -T -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" bash -s "$username" << 'ENDSSH'
        set -e
        USERNAME=$1

        SUDO=""
        if [ "$EUID" -ne 0 ]; then
            SUDO="sudo"
        fi

        # Remove from groups
        $SUDO gpasswd -d "$USERNAME" shipnode-deployers 2>/dev/null || true
        $SUDO gpasswd -d "$USERNAME" sudo 2>/dev/null || true

        # Lock account
        $SUDO usermod -L "$USERNAME"

        # Clear SSH keys
        USER_HOME=$($SUDO eval echo ~$USERNAME)
        if [ -f "$USER_HOME/.ssh/authorized_keys" ]; then
            $SUDO rm -f "$USER_HOME/.ssh/authorized_keys"
        fi
ENDSSH
}

# Command functions
cmd_user_sync() {
    load_config

    local yaml_file="users.yml"

    if [ ! -f "$yaml_file" ]; then
        error "users.yml not found. Create it first with user definitions."
    fi

    info "Syncing users from users.yml..."

    # Ensure .shipnode directory exists
    ssh -T -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" "mkdir -p $REMOTE_PATH/.shipnode"

    # Initialize users.json if it doesn't exist
    ssh -T -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" bash << ENDSSH
        if [ ! -f $REMOTE_PATH/.shipnode/users.json ]; then
            echo '{"users":[]}' > $REMOTE_PATH/.shipnode/users.json
        fi
ENDSSH

    # Parse users.yml
    local users_data=$(parse_users_yaml "$yaml_file")

    if [ -z "$users_data" ]; then
        warn "No users found in users.yml"
        return 0
    fi

    # Process each user
    while IFS='|' read -r username email password sudo public_key public_key_file public_keys; do
        # Validate username
        if ! validate_username "$username"; then
            warn "Invalid username: $username (skipping)"
            continue
        fi

        # Validate email
        if [ -z "$email" ]; then
            warn "No email for user: $username (skipping)"
            continue
        fi

        # Validate password if provided
        if [ -n "$password" ] && ! validate_password_hash "$password"; then
            warn "Invalid password hash for user: $username (skipping)"
            continue
        fi

        # Create user
        local result=$(create_remote_user "$username" "$email" "$password")

        if [ "$result" = "EXISTS" ]; then
            info "User already exists: $username (skipping)"
            continue
        fi

        local auth_method=""

        # Setup SSH if keys provided
        if [ -n "$public_key" ] || [ -n "$public_key_file" ] || [ -n "$public_keys" ]; then
            setup_user_ssh_dir "$username"
            auth_method="ssh-key"

            # Add inline public key
            if [ -n "$public_key" ]; then
                if validate_ssh_key "$public_key"; then
                    add_user_ssh_key "$username" "$public_key"
                else
                    warn "Invalid SSH key for user: $username"
                fi
            fi

            # Add key from file
            if [ -n "$public_key_file" ]; then
                local key_content=$(read_key_file "$public_key_file")
                if [ -n "$key_content" ] && validate_ssh_key "$key_content"; then
                    add_user_ssh_key "$username" "$key_content"
                else
                    warn "Invalid or missing SSH key file: $public_key_file"
                fi
            fi

            # Add multiple keys
            if [ -n "$public_keys" ]; then
                IFS=':::' read -ra KEYS <<< "$public_keys"
                for key in "${KEYS[@]}"; do
                    if validate_ssh_key "$key"; then
                        add_user_ssh_key "$username" "$key"
                    else
                        warn "Invalid SSH key in public_keys for user: $username"
                    fi
                done
            fi
        elif [ -n "$password" ]; then
            auth_method="password"
        else
            warn "User $username has no password or SSH keys (skipping)"
            continue
        fi

        # Grant deploy permissions
        grant_deploy_permissions "$username"

        # Grant sudo if requested
        if [ "$sudo" = "true" ]; then
            grant_sudo_access "$username"
        fi

        # Record user in users.json
        ssh -T -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" bash << ENDSSH
            cd $REMOTE_PATH/.shipnode
            CURRENT_DATE=\$(date -Is)
            jq ".users += [{\"username\":\"$username\",\"email\":\"$email\",\"auth\":\"$auth_method\",\"sudo\":$sudo,\"created_at\":\"\$CURRENT_DATE\"}]" users.json > users.json.tmp
            mv users.json.tmp users.json
ENDSSH

        # Report creation
        local sudo_msg=""
        [ "$sudo" = "true" ] && sudo_msg=", sudo enabled"

        if [ "$auth_method" = "password" ]; then
            success "Created user: $username (password auth, must change on first login$sudo_msg)"
        else
            success "Created user: $username (SSH key added$sudo_msg)"
        fi

    done <<< "$users_data"

    success "User sync complete"
}

cmd_user_list() {
    load_config

    info "Listing provisioned users..."

    # Check if users.json exists
    local has_users=$(ssh -T -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" "[ -f $REMOTE_PATH/.shipnode/users.json ] && echo 'yes' || echo 'no'")

    if [ "$has_users" = "no" ]; then
        warn "No users provisioned yet. Run 'shipnode user sync' first."
        return 0
    fi

    # Fetch and display users
    ssh -T -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" bash << ENDSSH
        cd $REMOTE_PATH/.shipnode

        echo ""
        printf "%-15s %-30s %-12s %-8s %s\n" "USERNAME" "EMAIL" "AUTH" "SUDO" "CREATED"
        echo "==================================================================================="

        cat users.json | jq -r '.users[] | "\(.username)|\(.email)|\(.auth)|\(.sudo)|\(.created_at)"' | while IFS='|' read -r username email auth sudo created; do
            # Format created date
            created_short=$(echo "$created" | cut -d'T' -f1)
            sudo_text="no"
            [ "$sudo" = "true" ] && sudo_text="yes"

            printf "%-15s %-30s %-12s %-8s %s\n" "$username" "$email" "$auth" "$sudo_text" "$created_short"
        done

        echo ""
        total=$(cat users.json | jq '.users | length')
        echo "Total: $total users"
ENDSSH
}

cmd_user_remove() {
    local username=$1

    if [ -z "$username" ]; then
        error "Usage: shipnode user remove <username>"
    fi

    load_config

    warn "This will revoke access for user: $username"
    read -p "Continue? (y/N) " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        info "Cancelled"
        return 0
    fi

    info "Revoking access for: $username..."

    # Revoke access
    revoke_user_access "$username"

    # Remove from users.json
    ssh -T -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" bash << ENDSSH
        if [ -f $REMOTE_PATH/.shipnode/users.json ]; then
            cd $REMOTE_PATH/.shipnode
            jq ".users = [.users[] | select(.username != \"$username\")]" users.json > users.json.tmp
            mv users.json.tmp users.json
        fi
ENDSSH

    success "Access revoked for: $username"
}

cmd_mkpasswd() {
    # Check if mkpasswd is available
    if ! command -v mkpasswd &> /dev/null; then
        error "mkpasswd not found. Install it with: sudo apt-get install whois"
    fi

    info "Generate password hash for users.yml"
    echo ""

    # Prompt for password (with confirmation)
    read -sp "Enter password: " password
    echo
    read -sp "Confirm password: " password2
    echo

    if [ "$password" != "$password2" ]; then
        error "Passwords do not match"
    fi

    if [ -z "$password" ]; then
        error "Password cannot be empty"
    fi

    # Generate hash
    local hash=$(mkpasswd -m sha-512 "$password")

    echo ""
    success "Password hash generated:"
    echo ""
    echo "$hash"
    echo ""
    info "Add this to users.yml:"
    echo "  password: \"$hash\""
    echo ""
}

# Load configuration
load_config() {
    if [ ! -f "shipnode.conf" ]; then
        error "shipnode.conf not found. Run 'shipnode init' first."
    fi

    info "Loading configuration..."

    # Source the config file with error handling
    set -a
    if ! source shipnode.conf 2>&1; then
        error "Failed to parse shipnode.conf"
    fi
    set +a

    # Validate required variables
    if [ -z "$APP_TYPE" ]; then
        error "APP_TYPE not set in shipnode.conf"
    fi
    if [ -z "$SSH_USER" ]; then
        error "SSH_USER not set in shipnode.conf"
    fi
    if [ -z "$SSH_HOST" ]; then
        error "SSH_HOST not set in shipnode.conf"
    fi
    if [ -z "$REMOTE_PATH" ]; then
        error "REMOTE_PATH not set in shipnode.conf"
    fi

    # Set defaults
    SSH_PORT="${SSH_PORT:-22}"
    ZERO_DOWNTIME="${ZERO_DOWNTIME:-true}"
    KEEP_RELEASES="${KEEP_RELEASES:-5}"
    HEALTH_CHECK_ENABLED="${HEALTH_CHECK_ENABLED:-true}"
    HEALTH_CHECK_PATH="${HEALTH_CHECK_PATH:-/health}"
    HEALTH_CHECK_TIMEOUT="${HEALTH_CHECK_TIMEOUT:-30}"
    HEALTH_CHECK_RETRIES="${HEALTH_CHECK_RETRIES:-3}"

    # Validate APP_TYPE
    if [ "$APP_TYPE" != "backend" ] && [ "$APP_TYPE" != "frontend" ]; then
        error "APP_TYPE must be 'backend' or 'frontend'"
    fi

    # Backend-specific validation
    if [ "$APP_TYPE" = "backend" ]; then
        if [ -z "$PM2_APP_NAME" ]; then
            error "PM2_APP_NAME required for backend apps"
        fi
        if [ -z "$BACKEND_PORT" ]; then
            error "BACKEND_PORT required for backend apps"
        fi
    fi
}

# Interactive users.yml generation
init_users_yaml() {
    local users_data=()

    info "Add deployment users to users.yml"
    echo ""

    while true; do
        local username email auth_method ssh_key password sudo_access

        # Prompt for username
        while true; do
            read -p "Username: " username
            if [ -z "$username" ]; then
                warn "Username cannot be empty"
                continue
            fi
            if ! validate_username "$username"; then
                warn "Invalid username (alphanumeric, dash, underscore, max 32 chars)"
                continue
            fi
            break
        done

        # Prompt for email
        while true; do
            read -p "Email: " email
            if [ -z "$email" ]; then
                warn "Email cannot be empty"
                continue
            fi
            if ! validate_email "$email"; then
                warn "Invalid email address"
                continue
            fi
            break
        done

        # Prompt for auth method
        echo ""
        echo "Authentication method:"
        echo "  1) SSH key"
        echo "  2) Password"
        read -p "Choose (1-2): " -n 1 auth_choice
        echo ""
        echo ""

        case "$auth_choice" in
            1)
                auth_method="ssh"
                # Prompt for SSH public key
                while true; do
                    read -p "SSH public key: " ssh_key
                    if [ -z "$ssh_key" ]; then
                        warn "SSH key cannot be empty"
                        continue
                    fi
                    if ! validate_ssh_key "$ssh_key"; then
                        warn "Invalid SSH key format"
                        continue
                    fi
                    break
                done
                ;;
            2)
                auth_method="password"
                # Prompt for password with confirmation
                while true; do
                    read -sp "Password: " password
                    echo
                    if [ -z "$password" ]; then
                        warn "Password cannot be empty"
                        continue
                    fi
                    read -sp "Confirm password: " password2
                    echo
                    if [ "$password" != "$password2" ]; then
                        warn "Passwords do not match"
                        continue
                    fi
                    break
                done
                ;;
            *)
                warn "Invalid choice, defaulting to SSH key"
                auth_method="ssh"
                while true; do
                    read -p "SSH public key: " ssh_key
                    if [ -z "$ssh_key" ]; then
                        warn "SSH key cannot be empty"
                        continue
                    fi
                    if ! validate_ssh_key "$ssh_key"; then
                        warn "Invalid SSH key format"
                        continue
                    fi
                    break
                done
                ;;
        esac

        # Prompt for sudo access
        sudo_access="false"
        if prompt_yes_no "Grant sudo access?"; then
            sudo_access="true"
        fi

        # Store user data
        users_data+=("$username|$email|$auth_method|$ssh_key|$password|$sudo_access")

        echo ""
        if ! prompt_yes_no "Add another user?"; then
            break
        fi
        echo ""
    done

    # Generate users.yml
    cat > users.yml << 'EOF'
# ShipNode User Configuration
# Sync users to server: shipnode user sync

users:
EOF

    for user_entry in "${users_data[@]}"; do
        IFS='|' read -r username email auth_method ssh_key password sudo_access <<< "$user_entry"

        echo "  - username: $username" >> users.yml
        echo "    email: $email" >> users.yml

        if [ "$auth_method" = "ssh" ]; then
            echo "    public_key: \"$ssh_key\"" >> users.yml
        else
            # Generate password hash
            local hash=$(generate_password_hash "$password")
            echo "    password: \"$hash\"" >> users.yml
        fi

        if [ "$sudo_access" = "true" ]; then
            echo "    sudo: true" >> users.yml
        fi

        echo "" >> users.yml
    done

    # Add footer comment
    echo "# Generate password hashes: shipnode mkpasswd" >> users.yml

    success "Created users.yml with ${#users_data[@]} user(s)"
    info "Review users.yml and run: shipnode user sync"
}

# Initialize config file
cmd_init() {
    if [ -f "shipnode.conf" ]; then
        read -p "shipnode.conf already exists. Overwrite? (y/N) " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            info "Aborted."
            exit 0
        fi
    fi

    cat > shipnode.conf << 'EOF'
# App type: "backend" or "frontend"
APP_TYPE=backend

# SSH Connection
SSH_USER=root
SSH_HOST=your-server-ip
SSH_PORT=22

# Remote path
REMOTE_PATH=/var/www/myapp

# Backend-specific
PM2_APP_NAME=myapp
BACKEND_PORT=3000

# Frontend-specific (optional)
DOMAIN=myapp.com

# Zero-downtime deployment (optional)
ZERO_DOWNTIME=true
KEEP_RELEASES=5

# Health checks for backend (optional)
HEALTH_CHECK_ENABLED=true
HEALTH_CHECK_PATH=/health
HEALTH_CHECK_TIMEOUT=30
HEALTH_CHECK_RETRIES=3
EOF

    success "Created shipnode.conf"
    info "Edit shipnode.conf with your server details, then run: shipnode deploy"

    # Optionally generate users.yml
    echo ""
    if prompt_yes_no "Add deployment users?"; then
        init_users_yaml
    else
        info "Skipped users.yml - create later with 'shipnode user sync'"
    fi
}

# Setup server (first-time)
cmd_setup() {
    load_config

    info "Setting up server $SSH_USER@$SSH_HOST..."

    # Check SSH connection
    if ! ssh -o ConnectTimeout=10 -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" "exit"; then
        error "Cannot connect to $SSH_USER@$SSH_HOST:$SSH_PORT"
    fi

    success "SSH connection successful"

    # Install Node.js, PM2, and Caddy
    info "Installing dependencies on server..."

    ssh -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" bash << 'ENDSSH'
        set -e

        # Detect if running as root and set sudo prefix
        SUDO=""
        if [ "$EUID" -ne 0 ]; then
            SUDO="sudo"
        fi

        # Install jq for JSON manipulation
        if ! command -v jq &> /dev/null; then
            echo "Installing jq..."
            $SUDO apt-get update
            $SUDO apt-get install -y jq
        else
            echo "jq already installed: $(jq --version)"
        fi

        # Install Node.js (using NodeSource)
        if ! command -v node &> /dev/null; then
            echo "Installing Node.js..."
            curl -fsSL https://deb.nodesource.com/setup_lts.x | $SUDO bash -
            $SUDO apt-get install -y nodejs
        else
            echo "Node.js already installed: $(node --version)"
        fi

        # Install PM2
        if ! command -v pm2 &> /dev/null; then
            echo "Installing PM2..."
            $SUDO npm install -g pm2
            pm2 startup systemd -u $USER --hp $HOME
        else
            echo "PM2 already installed: $(pm2 --version)"
        fi

        # Install Caddy
        if ! command -v caddy &> /dev/null; then
            echo "Installing Caddy..."
            $SUDO apt install -y debian-keyring debian-archive-keyring apt-transport-https curl
            curl -1sLf 'https://dl.cloudsmith.io/public/caddy/stable/gpg.key' | $SUDO gpg --dearmor -o /usr/share/keyrings/caddy-stable-archive-keyring.gpg
            curl -1sLf 'https://dl.cloudsmith.io/public/caddy/stable/debian.deb.txt' | $SUDO tee /etc/apt/sources.list.d/caddy-stable.list
            $SUDO apt update
            $SUDO apt install -y caddy
        else
            echo "Caddy already installed: $(caddy version)"
        fi
ENDSSH

    # Setup PostgreSQL if enabled
    setup_postgresql

    success "Server setup complete"
    info "Ready to deploy with: shipnode deploy"
}

# Deploy application
cmd_deploy() {
    load_config

    local SKIP_BUILD=false
    if [ "$1" = "--skip-build" ]; then
        SKIP_BUILD=true
    fi

    info "Deploying $APP_TYPE to $SSH_USER@$SSH_HOST..."

    # Create remote directory
    ssh -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" "mkdir -p $REMOTE_PATH"

    if [ "$APP_TYPE" = "backend" ]; then
        deploy_backend
    else
        deploy_frontend "$SKIP_BUILD"
    fi
}

deploy_backend() {
    info "Deploying backend application..."

    # Check if package.json exists
    [ ! -f "package.json" ] && error "package.json not found in current directory"

    if [ "$ZERO_DOWNTIME" = "true" ]; then
        deploy_backend_zero_downtime
    else
        deploy_backend_legacy
    fi
}

deploy_backend_legacy() {
    info "Using legacy deployment (non-zero-downtime)..."

    # Rsync application files
    info "Syncing files to server..."
    rsync -avz --progress \
        --exclude 'node_modules' \
        --exclude '.env' \
        --exclude '.git' \
        --exclude '.gitignore' \
        --exclude 'shipnode.conf' \
        --exclude '*.log' \
        -e "ssh -p $SSH_PORT" \
        ./ "$SSH_USER@$SSH_HOST:$REMOTE_PATH/"

    success "Files synced"

    # Install dependencies and start with PM2
    info "Installing dependencies and starting app..."

    ssh -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" bash << ENDSSH
        set -e
        cd $REMOTE_PATH
        npm install --production

        # Start or reload with PM2
        if pm2 describe $PM2_APP_NAME > /dev/null 2>&1; then
            pm2 reload $PM2_APP_NAME
        else
            if [ -f ecosystem.config.js ]; then
                pm2 start ecosystem.config.js
            else
                pm2 start npm --name "$PM2_APP_NAME" -- start
            fi
        fi

        pm2 save
ENDSSH

    success "Backend deployed and running"

    # Optionally configure Caddy
    if [ -n "$DOMAIN" ]; then
        configure_caddy_backend
    fi

    info "Run 'shipnode status' to check app status"
}

deploy_backend_zero_downtime() {
    info "Using zero-downtime deployment..."

    # Acquire deployment lock
    info "Acquiring deployment lock..."
    acquire_deploy_lock
    trap release_deploy_lock EXIT
    success "Lock acquired"

    # Generate release timestamp
    local timestamp=$(generate_release_timestamp)
    local release_path=$(get_release_path "$timestamp")

    info "Creating release: $timestamp"

    # Setup release structure on first deploy
    info "Setting up release structure..."
    setup_release_structure
    success "Release structure ready"

    # Get previous release for potential rollback
    local previous_release=$(get_previous_release)

    # Rsync to new release directory
    info "Syncing files to release directory..."
    rsync -avz --progress \
        --exclude 'node_modules' \
        --exclude '.env' \
        --exclude '.git' \
        --exclude '.gitignore' \
        --exclude 'shipnode.conf' \
        --exclude '*.log' \
        -e "ssh -p $SSH_PORT" \
        ./ "$SSH_USER@$SSH_HOST:$release_path/"

    success "Files synced to $release_path"

    # Link shared resources and install dependencies
    info "Setting up release environment..."
    ssh -T -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" bash << ENDSSH
        set -e
        cd $release_path

        # Link shared .env if it exists
        if [ -f $REMOTE_PATH/shared/.env ]; then
            ln -sf $REMOTE_PATH/shared/.env .env
        fi

        # Install dependencies
        npm install --production
ENDSSH

    success "Release prepared"

    # Atomic symlink switch
    info "Switching to new release..."
    switch_symlink "$release_path"

    # Reload PM2
    info "Reloading application..."
    ssh -T -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" bash << ENDSSH
        set -e
        cd $REMOTE_PATH/current

        if pm2 describe $PM2_APP_NAME > /dev/null 2>&1; then
            pm2 reload $PM2_APP_NAME --update-env
        else
            if [ -f ecosystem.config.js ]; then
                pm2 start ecosystem.config.js
            else
                pm2 start npm --name "$PM2_APP_NAME" -- start
            fi
        fi

        pm2 save
ENDSSH

    # Wait for app to start
    sleep 3

    # Run health check if enabled
    if [ "$HEALTH_CHECK_ENABLED" = "true" ]; then
        if ! perform_health_check; then
            warn "Health check failed, rolling back..."
            if [ -n "$previous_release" ]; then
                rollback_to_release "$previous_release"
                record_release "$timestamp" "failed"
                error "Deployment failed, rolled back to $previous_release"
            else
                error "Health check failed and no previous release to rollback to"
            fi
        fi
    fi

    # Record successful release
    record_release "$timestamp" "success"
    success "Release $timestamp deployed successfully"

    # Cleanup old releases
    cleanup_old_releases

    # Configure Caddy if needed
    if [ -n "$DOMAIN" ]; then
        configure_caddy_backend
    fi

    info "Run 'shipnode status' to check app status"
}

deploy_frontend() {
    local SKIP_BUILD=$1
    info "Deploying frontend application..."

    # Build if package.json exists and not skipping
    if [ -f "package.json" ] && [ "$SKIP_BUILD" = false ]; then
        info "Building frontend..."
        npm run build || error "Build failed"
        success "Build complete"
    fi

    # Determine build directory
    local BUILD_DIR="dist"
    if [ -d "build" ]; then
        BUILD_DIR="build"
    elif [ -d "public" ]; then
        BUILD_DIR="public"
    fi

    [ ! -d "$BUILD_DIR" ] && error "$BUILD_DIR directory not found"

    if [ "$ZERO_DOWNTIME" = "true" ]; then
        deploy_frontend_zero_downtime "$BUILD_DIR"
    else
        deploy_frontend_legacy "$BUILD_DIR"
    fi
}

deploy_frontend_legacy() {
    local BUILD_DIR=$1

    # Rsync build directory
    info "Syncing $BUILD_DIR to server..."
    rsync -avz --progress --delete \
        -e "ssh -p $SSH_PORT" \
        "$BUILD_DIR/" "$SSH_USER@$SSH_HOST:$REMOTE_PATH/"

    success "Frontend deployed"

    # Configure Caddy
    if [ -n "$DOMAIN" ]; then
        configure_caddy_frontend
    else
        warn "No DOMAIN set. Configure Caddy manually to serve $REMOTE_PATH"
    fi
}

deploy_frontend_zero_downtime() {
    local BUILD_DIR=$1

    info "Using zero-downtime deployment..."

    # Acquire deployment lock
    acquire_deploy_lock
    trap release_deploy_lock EXIT

    # Generate release timestamp
    local timestamp=$(generate_release_timestamp)
    local release_path=$(get_release_path "$timestamp")

    info "Creating release: $timestamp"

    # Setup release structure
    setup_release_structure

    # Rsync build output to release directory
    info "Syncing $BUILD_DIR to release directory..."
    rsync -avz --progress --delete \
        -e "ssh -p $SSH_PORT" \
        "$BUILD_DIR/" "$SSH_USER@$SSH_HOST:$release_path/"

    success "Files synced to $release_path"

    # Atomic symlink switch
    info "Switching to new release..."
    switch_symlink "$release_path"

    # Record release
    record_release "$timestamp" "success"
    success "Release $timestamp deployed successfully"

    # Cleanup old releases
    cleanup_old_releases

    # Configure Caddy
    if [ -n "$DOMAIN" ]; then
        configure_caddy_frontend
    else
        warn "No DOMAIN set. Configure Caddy manually to serve $REMOTE_PATH/current"
    fi
}

configure_caddy_backend() {
    info "Configuring Caddy reverse proxy for $DOMAIN..."

    local CADDY_CONFIG="/etc/caddy/Caddyfile"

    ssh -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" bash << ENDSSH
        set -e

        # Backup existing Caddyfile
        [ -f $CADDY_CONFIG ] && cp $CADDY_CONFIG ${CADDY_CONFIG}.backup

        # Create Caddyfile
        cat > $CADDY_CONFIG << 'EOF'
$DOMAIN {
    reverse_proxy localhost:$BACKEND_PORT
    encode gzip

    log {
        output file /var/log/caddy/${PM2_APP_NAME}.log
    }
}
EOF

        # Reload Caddy
        caddy reload --config $CADDY_CONFIG
ENDSSH

    success "Caddy configured for $DOMAIN → localhost:$BACKEND_PORT"
}

configure_caddy_frontend() {
    info "Configuring Caddy static file server for $DOMAIN..."

    local CADDY_CONFIG="/etc/caddy/Caddyfile"
    local SERVE_PATH="$REMOTE_PATH"

    # Use current symlink if zero-downtime is enabled
    if [ "$ZERO_DOWNTIME" = "true" ]; then
        SERVE_PATH="$REMOTE_PATH/current"
    fi

    ssh -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" bash << ENDSSH
        set -e

        # Backup existing Caddyfile
        [ -f $CADDY_CONFIG ] && cp $CADDY_CONFIG ${CADDY_CONFIG}.backup

        # Create Caddyfile
        cat > $CADDY_CONFIG << 'EOF'
$DOMAIN {
    root * $SERVE_PATH
    file_server
    encode gzip

    try_files {path} /index.html

    log {
        output file /var/log/caddy/frontend.log
    }
}
EOF

        # Reload Caddy
        caddy reload --config $CADDY_CONFIG
ENDSSH

    success "Caddy configured for $DOMAIN → $SERVE_PATH"
}

# Show app status
cmd_status() {
    load_config

    if [ "$APP_TYPE" = "backend" ]; then
        info "Checking PM2 status for $PM2_APP_NAME..."
        ssh -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" "pm2 status $PM2_APP_NAME"
    else
        info "Checking frontend files..."
        ssh -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" "ls -lh $REMOTE_PATH | head -20"
    fi
}

# View logs (backend only)
cmd_logs() {
    load_config

    if [ "$APP_TYPE" != "backend" ]; then
        error "Logs command only available for backend apps"
    fi

    info "Streaming logs for $PM2_APP_NAME (Ctrl+C to exit)..."
    ssh -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" "pm2 logs $PM2_APP_NAME"
}

# Restart app (backend only)
cmd_restart() {
    load_config

    if [ "$APP_TYPE" != "backend" ]; then
        error "Restart command only available for backend apps"
    fi

    info "Restarting $PM2_APP_NAME..."
    ssh -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" "pm2 restart $PM2_APP_NAME"
    success "App restarted"
}

# Stop app (backend only)
cmd_stop() {
    load_config

    if [ "$APP_TYPE" != "backend" ]; then
        error "Stop command only available for backend apps"
    fi

    info "Stopping $PM2_APP_NAME..."
    ssh -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" "pm2 stop $PM2_APP_NAME"
    success "App stopped"
}

# Clear deployment lock
cmd_unlock() {
    load_config

    info "Checking for deployment lock on $SSH_USER@$SSH_HOST..."

    local lock_info
    lock_info=$(ssh -T -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" bash -s "$REMOTE_PATH" << 'ENDSSH'
        REMOTE_PATH="$1"
        LOCK_FILE="$REMOTE_PATH/.shipnode/deploy.lock"

        if [ -f "$LOCK_FILE" ]; then
            LOCK_AGE=$(( $(date +%s) - $(stat -c %Y "$LOCK_FILE") ))
            echo "FOUND:${LOCK_AGE}"
        else
            echo "NOTFOUND"
        fi
ENDSSH
    )

    if [[ "$lock_info" == "NOTFOUND" ]]; then
        info "No deployment lock found"
        return 0
    fi

    local lock_age
    lock_age=$(echo "$lock_info" | cut -d: -f2)

    warn "Found deployment lock (age: ${lock_age}s)"
    read -p "Clear this lock? (y/N) " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        info "Lock not cleared"
        return 0
    fi

    ssh -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" "rm -f $REMOTE_PATH/.shipnode/deploy.lock"
    success "Deployment lock cleared"
}

# Rollback to previous release
cmd_rollback() {
    load_config

    if [ "$ZERO_DOWNTIME" != "true" ]; then
        error "Rollback only available with zero-downtime deployment enabled"
    fi

    local steps_back=${1:-1}

    info "Fetching release history..."

    # Get target release
    local target_release=$(ssh -T -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" bash << ENDSSH
        cd $REMOTE_PATH/.shipnode
        cat releases.json | jq -r ".[-$((steps_back + 1))].timestamp // empty"
ENDSSH
)

    if [ -z "$target_release" ]; then
        error "No release found to rollback to (requested $steps_back steps back)"
    fi

    # Confirm rollback
    warn "This will rollback to release: $target_release"
    read -p "Continue? (y/N) " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        info "Rollback cancelled"
        exit 0
    fi

    # Perform rollback
    rollback_to_release "$target_release"

    # Run health check for backend
    if [ "$APP_TYPE" = "backend" ] && [ "$HEALTH_CHECK_ENABLED" = "true" ]; then
        sleep 3
        if perform_health_check; then
            success "Rollback successful and health check passed"
        else
            warn "Rollback completed but health check failed"
        fi
    else
        success "Rollback successful"
    fi
}

# List available releases
cmd_releases() {
    load_config

    if [ "$ZERO_DOWNTIME" != "true" ]; then
        error "Releases command only available with zero-downtime deployment enabled"
    fi

    info "Fetching releases..."

    ssh -T -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" bash << ENDSSH
        cd $REMOTE_PATH

        # Get current release
        CURRENT=""
        if [ -L current ]; then
            CURRENT=\$(readlink current | xargs basename)
        fi

        echo ""
        echo "Available releases:"
        echo "==================="

        cd .shipnode
        cat releases.json | jq -r '.[] | "\(.timestamp) - \(.date) - \(.status)"' | while read line; do
            timestamp=\$(echo \$line | cut -d' ' -f1)
            if [ "\$timestamp" = "\$CURRENT" ]; then
                echo "→ \$line (current)"
            else
                echo "  \$line"
            fi
        done

        echo ""
        echo "Total: \$(cat releases.json | jq 'length') releases"
ENDSSH
}

# Migrate existing deployment to release structure
cmd_migrate() {
    load_config

    if [ "$ZERO_DOWNTIME" != "true" ]; then
        error "Migration only needed when enabling zero-downtime deployment"
    fi

    warn "This will migrate your existing deployment to the release structure"
    warn "Existing files will be moved to a new release directory"
    read -p "Continue? (y/N) " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        info "Migration cancelled"
        exit 0
    fi

    info "Migrating to release structure..."

    local timestamp=$(generate_release_timestamp)

    ssh -T -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" bash << ENDSSH
        set -e
        cd $REMOTE_PATH

        # Create structure
        mkdir -p releases shared .shipnode
        echo "[]" > .shipnode/releases.json

        # Move existing files to first release
        mkdir -p releases/$timestamp

        # Move all files except the new directories
        find . -maxdepth 1 -mindepth 1 \
            ! -name 'releases' \
            ! -name 'shared' \
            ! -name '.shipnode' \
            ! -name 'current' \
            -exec mv {} releases/$timestamp/ \;

        # Move .env to shared if it exists
        if [ -f releases/$timestamp/.env ]; then
            mv releases/$timestamp/.env shared/.env
            ln -sf $REMOTE_PATH/shared/.env releases/$timestamp/.env
        fi

        # Create current symlink
        ln -sfn releases/$timestamp current

        # Update PM2 to use current directory if backend
        if [ "$APP_TYPE" = "backend" ]; then
            cd current
            if pm2 describe $PM2_APP_NAME > /dev/null 2>&1; then
                pm2 delete $PM2_APP_NAME
                if [ -f ecosystem.config.js ]; then
                    pm2 start ecosystem.config.js
                else
                    pm2 start npm --name "$PM2_APP_NAME" -- start
                fi
                pm2 save
            fi
        fi

        # Record initial release
        CURRENT_DATE=\$(date -Is)
        jq ". + [{\"timestamp\":\"$timestamp\",\"date\":\"\$CURRENT_DATE\",\"status\":\"migrated\"}]" .shipnode/releases.json > .shipnode/releases.json.tmp
        mv .shipnode/releases.json.tmp .shipnode/releases.json
ENDSSH

    success "Migration complete"
    info "Your deployment now uses the release structure"
    info "Current release: $timestamp"

    # Update Caddy config
    if [ -n "$DOMAIN" ]; then
        info "Updating Caddy configuration..."
        if [ "$APP_TYPE" = "backend" ]; then
            configure_caddy_backend
        else
            configure_caddy_frontend
        fi
    fi
}

# Upload .env file to server
cmd_env() {
    load_config

    # Check if .env file exists locally
    if [ ! -f .env ]; then
        error ".env file not found in current directory"
    fi

    info "Uploading .env file to server..."

    # Determine target path based on deployment mode
    if [ "$ZERO_DOWNTIME" = "true" ]; then
        # Upload to shared directory for zero-downtime deployments
        TARGET_PATH="$REMOTE_PATH/shared/.env"
        ssh -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" "mkdir -p $REMOTE_PATH/shared"
    else
        # Upload directly to app directory for legacy deployments
        TARGET_PATH="$REMOTE_PATH/.env"
        ssh -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" "mkdir -p $REMOTE_PATH"
    fi

    # Upload the .env file
    scp -P "$SSH_PORT" .env "$SSH_USER@$SSH_HOST:$TARGET_PATH"

    success ".env file uploaded to $TARGET_PATH"

    # Restart backend app if running to reload env vars
    if [ "$APP_TYPE" = "backend" ]; then
        info "Restarting app to reload environment variables..."
        if ssh -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" "pm2 describe $PM2_APP_NAME" &> /dev/null; then
            ssh -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" "pm2 reload $PM2_APP_NAME"
            success "App restarted with new environment variables"
        else
            warn "App not running. Environment variables will be loaded on next deploy."
        fi
    fi
}

# Show help
cmd_help() {
    cat << EOF
ShipNode v$VERSION - Simple Node.js Deployment Tool

Usage: shipnode <command> [options]

Commands:
    init                Create shipnode.conf (+ optional users.yml)
    setup               First-time server setup (Node, PM2, Caddy, jq)
    deploy              Deploy the application
    deploy --skip-build Deploy without running build step
    env                 Upload .env file to server
    status              Check application status
    logs                View application logs (backend only)
    restart             Restart application (backend only)
    stop                Stop application (backend only)
    unlock              Clear deployment lock (if stuck)
    rollback [N]        Rollback to previous release (or N steps back)
    releases            List all available releases
    migrate             Migrate existing deployment to release structure
    help                Show this help message

User Management:
    user sync           Sync users from users.yml to server
    user list           List all provisioned users
    user remove <user>  Revoke access for a specific user
    mkpasswd            Generate password hash for users.yml

Configuration:
    Edit shipnode.conf to configure your deployment settings.
    Supports both backend (Node.js + PM2) and frontend (static files) apps.

Zero-Downtime Deployment:
    ZERO_DOWNTIME=true           Enable atomic deployments (default)
    KEEP_RELEASES=5              Number of releases to keep (default: 5)
    HEALTH_CHECK_ENABLED=true    Enable health checks (default: true)
    HEALTH_CHECK_PATH=/health    Health endpoint (default: /health)
    HEALTH_CHECK_TIMEOUT=30      Health check timeout seconds (default: 30)
    HEALTH_CHECK_RETRIES=3       Number of health check retries (default: 3)

User Provisioning:
    Create users.yml with user definitions, then run 'shipnode user sync'.
    Generate password hashes with 'shipnode mkpasswd'.

Examples:
    shipnode init               # Create config file
    shipnode setup              # Setup server (first time)
    shipnode deploy             # Deploy your app
    shipnode env                # Upload .env file to server
    shipnode unlock             # Clear stuck deployment lock
    shipnode rollback           # Rollback to previous release
    shipnode rollback 2         # Rollback 2 releases back
    shipnode releases           # List all releases
    shipnode migrate            # Migrate to release structure
    shipnode mkpasswd           # Generate password hash
    shipnode user sync          # Provision users from users.yml
    shipnode user list          # List provisioned users
    shipnode user remove alice  # Revoke access for alice

EOF
}

# Main command dispatcher
main() {
    case "${1:-}" in
        init)
            cmd_init
            ;;
        setup)
            cmd_setup
            ;;
        deploy)
            cmd_deploy "$2"
            ;;
        env)
            cmd_env
            ;;
        status)
            cmd_status
            ;;
        logs)
            cmd_logs
            ;;
        restart)
            cmd_restart
            ;;
        stop)
            cmd_stop
            ;;
        unlock)
            cmd_unlock
            ;;
        rollback)
            cmd_rollback "$2"
            ;;
        releases)
            cmd_releases
            ;;
        migrate)
            cmd_migrate
            ;;
        user)
            case "${2:-}" in
                sync)
                    cmd_user_sync
                    ;;
                list)
                    cmd_user_list
                    ;;
                remove)
                    cmd_user_remove "$3"
                    ;;
                *)
                    error "Unknown user command: ${2:-}\nAvailable: sync, list, remove"
                    ;;
            esac
            ;;
        mkpasswd)
            cmd_mkpasswd
            ;;
        help|--help|-h)
            cmd_help
            ;;
        "")
            cmd_help
            ;;
        *)
            error "Unknown command: $1\nRun 'shipnode help' for usage."
            ;;
    esac
}

main "$@"
